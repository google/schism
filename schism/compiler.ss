;; Copyright 2018, 2019 Google LLC
;;
;; Licensed under the Apache License, Version 2.0 (the License);
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an AS IS BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.

(library (schism compiler)
  (export compile-library compile-stdin->stdout
          compile-stdin->module-package compile-module-package->stdout)
  (import (rnrs)
	  (rnrs mutable-pairs)
          (only (chezscheme) gensym))
  (define (tag-size) 3)
  (define (fixnum-mask) -8) ;; a magic mask that turns ptrs into fixnums
  (define (tag-mask) 7)
  (define (tag-constant value tag)
    (bitwise-ior (bitwise-arithmetic-shift-left value (tag-size)) tag))
  ;; fixnums are 0 so most arithmetic doesn't require shifting
  (define (fixnum-tag) 0)
  ;; constant-tag is used for implementation constants, such as #f, #t and ()
  (define (constant-tag) 1)
  (define (constant-false) (tag-constant 0 (constant-tag)))
  (define (constant-true) (tag-constant 1 (constant-tag)))
  (define (constant-null) (tag-constant 2 (constant-tag)))
  (define (constant-eof) (tag-constant 3 (constant-tag)))
  (define (constant-void) (tag-constant 4 (constant-tag)))
  (define (pair-tag) 2)
  (define (char-tag) 3)
  (define (string-tag) 4)
  (define (symbol-tag) 5)
  (define (closure-tag) 6)

  (define (allocation-pointer) 0)
  (define (word-size) 4)
  (define (symbol-table-width) 32)

  ;; ====================== ;;
  ;; Helpers, etc.          ;;
  ;; ====================== ;;
  (define (trace-value x)
    (write x)
    (newline)
    x)
  (define (trace-and-error x where what)
    (trace-value x)
    (error where what))

  (define (index-of-helper x ls index)
    (unless (pair? ls)
      (trace-and-error x 'index-of "Could not find item"))
    (if (eq? x (car ls))
        index
        (index-of-helper x (cdr ls) (+ 1 index))))
  (define (index-of x ls)
    (index-of-helper x ls 0))

  (define (primitives)
    (expand-macros
     `(;; display, newline, etc are all just enough to compile. We'll fill them in later.
       (define (display x)
         (cond
          ((pair? x)
           (%log-char #\()
           (display (car x))
           (%display-pair-tail (cdr x)))
          ((null? x) (%log-char #\() (%log-char #\)))
          ((symbol? x) (%display-symbol x))
          ((boolean? x) (%log-char #\#) (%log-char (if x #\t #\f)))
          ((number? x)
           (%display-leading-digits (div0 x 10))
           (%display-least-significant-digit x))
          ((char? x) (%log-char #\#) (%log-char #\\) (%log-char x))
          ((string? x) (%log-char #\") (%display-raw-string x) (%log-char #\"))
          (else (%display-raw-string "<!display unknown unimplemented!>"))))
       (define (%display-leading-digits n)
         (unless (zero? n)
           (%display-leading-digits (div0 n 10))
           (%display-least-significant-digit n)))
       (define (%display-least-significant-digit n)
         (%log-char (integer->char (+ (char->integer #\0) (mod0 n 10)))))
       (define (%display-pair-tail x)
         (cond
          ((null? x) (%log-char #\)))
          ((pair? x)
           (%log-char #\space)
           (display (car x))
           (%display-pair-tail (cdr x)))
          (else
           (%log-char #\space) (%log-char #\.) (%log-char #\space)
           (display x)
           (%log-char #\)))))
       (define (%display-raw-string s)
         (unless (string? s)
           (error '%display-raw-string "not a string"))
         (%display-chars-as-string (string->list s)))
       (define (%display-chars-as-string chars)
         (unless (null? chars)
           (unless (pair? chars)
             (error '%display-chars-as-string "not a list of chars"))
           (%log-char (car chars))
           (%display-chars-as-string (cdr chars))))
       (define (%display-symbol sym)
         (let ((name (car (%set-tag sym ,(pair-tag)))))
           (cond
            ((string? name)
             (%display-raw-string name))
            (else
             (%log-char #\#) (%log-char #\<)
             (%log-char #\g) (%log-char #\e) (%log-char #\n)
             (%log-char #\s) (%log-char #\y) (%log-char #\m)
             (%log-char #\space)
             (%display-raw-string (list->string name))
             (%log-char #\space)
             (display (%as-fixnum sym))
             (%log-char #\>)))))
       (define (write x)
         (if (string? x)
             (%display-raw-string x)
             (display x)))
       (define (newline)
         (%flush-log))
       (define (%base-pair) (%set-tag ,(allocation-pointer) ,(pair-tag)))
       (define (%symbol-table) (cdr (%base-pair)))
       (define (%alloc tag num-words)
         ;; heap pointers must be 8-byte aligned, since we store them
         ;; as raw offsets into the linear memory, but we need space
         ;; for the three tag bits. Since we always mask off the
         ;; bottom three bits, we need to allocate in double-words. We
         ;; add 1 before dividing to make sure we round up if needed.
         (let* ((dwords (div0 (+ 1 num-words) 2))
                (new-alloc-pointer (+ dwords (car (%base-pair))))
                (allocation (car (%base-pair))))
           (set-car! (%base-pair) new-alloc-pointer)
           ;; Add one dword to the pointer we allocated to make sure
           ;; we skip the base air.
           (%set-tag (+ allocation 1) tag)))
       (define (cons a d)
         (let ((p (%alloc ,(pair-tag) 2)))
           (%set-car! p a)
           (%set-cdr! p d)
           p))
       (define (set-car! p a)
         (unless (pair? p) (error 'set-car! "set-car!: not a pair"))
         (%set-car! p a))
       (define (set-cdr! p d)
         (unless (pair? p) (error 'set-cdr! "set-cdr!: not a pair"))
         (%set-cdr! p d))
       (define (car p)
         (unless (pair? p) (error 'car "car: not a pair"))
         (%read-mem (%as-fixnum p) 0))
       (define (cdr p)
         (unless (pair? p) (error 'cdr "cdr: not a pair"))
         (%read-mem (%as-fixnum p) ,(word-size)))
       (define (caar p) (car (car p)))
       (define (cadr p) (car (cdr p)))
       (define (cdar p) (cdr (car p)))
       (define (cddr p) (cdr (cdr p)))
       (define (caaar p) (car (caar p)))
       (define (caadr p) (car (cadr p)))
       (define (cadar p) (car (cdar p)))
       (define (cddar p) (cdr (cdar p)))
       (define (caddr p) (car (cddr p)))
       (define (cdadr p) (cdr (cadr p)))
       (define (cdddr p) (cdr (cddr p)))
       (define (caadar p) (car (cadar p)))
       (define (caaddr p) (car (caddr p)))
       (define (caddar p) (car (cddar p)))
       (define (cadadr p) (car (cdadr p)))
       (define (cadddr p) (car (cdddr p)))
       (define (cdaddr p) (cdr (caddr p)))
       (define (assq x ls)
         (if (pair? ls)
             (if (eq? x (caar ls))
                 (car ls)
                 (assq x (cdr ls)))
	     (if (null? ls)
		 #f
		 (begin (display x) (newline) (error 'assq "not a list")))))
       (define (length ls)
         (cond
          ((null? ls) 0)
          ((pair? ls) (+ 1 (length (cdr ls))))
          (else (error 'length "argument is not a proper list"))))
       (define (list-tail list n)
	 (if (zero? n)
	     list
	     (list-tail (cdr list) (- n 1))))
       (define (list-ref list n)
         (car (list-tail list n)))
       (define (append a b)
         (if (null? a) b (cons (car a) (append (cdr a) b))))
       (define (char->integer c) (%as-fixnum c)) ;; TODO: check tag
       (define (integer->char c) (%set-tag c ,(char-tag)))
       (define (char-between c c1 c2) ;; inclusive
         (if (char-ci<? c c1)
             #f
             (if (char-ci<? c c2)
                 #t
                 (if (eq? c c2) #t #f))))
       (define (char-numeric? c)
         (char-between c #\0 #\9))
       (define (char-whitespace? c)
         (or (eq? c #\space) (eq? c #\tab) (eq? c #\newline)))
       (define (char-hex? c)
         (or (char-numeric? c) (char-between c #\a #\f)))
       (define (char-ci<? c1 c2)
         (< (char->integer c1) (char->integer c2)))
       (define (list->string ls)
         (unless (pair? ls) (error 'list->string "list->string: not a pair"))
         ;; For now we represent strings as lists of characters. That
         ;; means converting between the two is just a matter of
         ;; changing the tags.
         (%set-tag ls ,(string-tag)))
       (define (string->list s)
         (unless (string? s)
           ;; Calling error here can lead to an infinite loop, so we
           ;; generate an unreachable instead.
           (%unreachable))
         (%set-tag s ,(pair-tag)))
       (define (string-equal? s1 s2)
         (list-all-eq? (string->list s1) (string->list s2)))
       (define (hash-chars chars h)
         (if (null? chars)
             h
             (hash-chars (cdr chars) (+ (char->integer (car chars)) h))))
       (define (make-symbol-table n)
         (if (zero? n)
             '()
             (cons '() (make-symbol-table (- n 1)))))
       (define (%find-symbol-by-name s ls)
         (and (pair? ls)
              (if (string-equal? s (car ls))
                  (%set-tag ls ,(symbol-tag))
                  (%find-symbol-by-name s (cdr ls)))))
       (define (gensym str) ;; Creates a brand new symbol that cannot be reused
         (let ((x (cons (string->list str) '())))
           (%set-tag x ,(symbol-tag))))
       (define (symbol->string x)
         (unless (symbol? x) (error 'symbol->string "not a symbol"))
         (let ((name (car (%set-tag x ,(pair-tag)))))
           (if (string? name)
               name
               (list->string name))))
       (define (string->symbol str)
         (when (zero? (%symbol-table))
           (set-cdr! (%base-pair) (make-symbol-table ,(symbol-table-width))))
         (let* ((idx (bitwise-and (hash-chars (string->list str) 0)
                                  ,(- (symbol-table-width) 1)))
                (bucket (list-tail (%symbol-table) idx)))
           (or (%find-symbol-by-name str (car bucket))
               (let ((x (cons str (car bucket))))
                 (set-car! bucket x)
                 (%set-tag x ,(symbol-tag))))))
       (define (list-all-eq? a b)
         (if (null? a)
             (null? b)
             (and (not (null? b))
                  (eq? (car a) (car b))
                  (list-all-eq? (cdr a) (cdr b)))))
       (define (> a b)
         (< b a))
       (define (max a b)
         (if (< a b) b a))
       (define (read)
         (read-skip-whitespace-and-comments)
         (start-read (read-char)))
       (define (start-read c)
         (cond
          ((char-numeric? c)
           (read-number (- (char->integer c) (char->integer #\0))))
          ((and (eq? c #\-) (char-numeric? (peek-char)))
           (- 0 (read-number 0)))
          ((eq? c #\#)
           (read-hash (read-char)))
          ((eq? c #\()
           (read-list))
          ((eq? c #\')
           (cons 'quote (cons (read) '())))
          ((eq? c #\`)
           (cons 'quasiquote (cons (read) '())))
          ((eq? c #\,)
           (cons 'unquote (cons (read) '())))
          ((eq? c #\")
           (list->string (read-string)))
          ((char-symbolic? c)
           (string->symbol (list->string (cons c (read-symbol)))))
          (else
           (error 'start-read "malformed datum"))))
       (define (read-string)
         (let ((c (read-char)))
           (if (eq? c #\")
               '()
               (cons c (read-string)))))
       (define (char-symbolic? c)
         (not (or (char-whitespace? c) (eq? c #\() (eq? c #\)) (eq? c #\;))))
       (define (read-symbol)
         (if (char-symbolic? (peek-char))
             (cons (read-char) (read-symbol))
             '()))
       (define (read-list)
         (read-skip-whitespace-and-comments)
         (cond
          ((eq? (peek-char) #\))
           (read-char)
           '())
          ((eq? (peek-char) #\.)
           (read-char)
           (let ((d (read)))
             (read-skip-whitespace-and-comments)
             (unless (eq? (read-char) #\))
               (error 'read-list "invalid improper list"))
             d))
          (else
           (let ((a (read)))
             (let ((d (read-list)))
               (cons a d))))))
       (define (read-skip-whitespace-and-comments)
         (cond
          ((char-whitespace? (peek-char))
           (read-char)
           (read-skip-whitespace-and-comments))
          ((eq? (peek-char) #\;)
           (read-skip-line))
          (else #f)))
       (define (read-skip-line)
         (cond
          ((eq? (peek-char) #\newline)
           (read-skip-whitespace-and-comments))
          (else
           (read-char)
           (read-skip-line))))
       (define (read-number acc)
         (if (char-numeric? (peek-char))
             (read-number (+ (* acc 10) (- (char->integer (read-char))
                                           (char->integer #\0))))
             acc))
       (define (hex-digit c)
         (if (char-numeric? c)
             (- (char->integer c)
                (char->integer #\0))
             (+ 10 (- (char->integer c)
                      (char->integer #\a)))))
       (define (read-hex acc)
         (if (char-hex? (peek-char))
             (read-hex (+ (* acc 16) (hex-digit (read-char))))
             acc))
       (define (read-hash c)
         (cond
          ((eq? c #\f)
           #f)
          ((eq? c #\t)
           #t)
          ((eq? c #\\)
           (let ((c (read-char)))
             (cond
              ((and (eq? c #\s) (eq? (peek-char) #\p)) ;; check if this is a space
               (let ((p (read-char)) (a (read-char)) (c (read-char)) (e (read-char)))
                 #\space))
              ((and (eq? c #\t) (eq? (peek-char) #\a)) ;; check if this is a tab
               (let ((a (read-char)) (b (read-char)))
                 #\tab))
              ((and (eq? c #\n) (eq? (peek-char) #\e)) ;; check if this is a newline
               (let ((e (read-char)) (w (read-char)) (l (read-char)) (i (read-char))
                     (n (read-char)) (e^ (read-char)))
                 #\newline))
              (else c))))
          ((eq? c #\x)
           (read-hex 0))
          (else #f)))
       (define (zero? n)
         (eq? n 0))
       (define (null? x)
         (eq? x '()))
       (define (pair? p)
         (eq? (%get-tag p) ,(pair-tag)))
       (define (boolean? p)
         (or (eq? p #t) (eq? p #f)))
       (define (number? p)
         (eq? (%get-tag p) ,(fixnum-tag)))
       (define (char? p)
         (eq? (%get-tag p) ,(char-tag)))
       (define (string? p)
         (eq? (%get-tag p) ,(string-tag)))
       (define (symbol? p)
         (eq? (%get-tag p) ,(symbol-tag)))
       (define (procedure? p)
         (eq? (%get-tag p) ,(closure-tag)))
       (define (map p ls)
	 (if (null? ls)
	     '()
	     (cons (p (car ls)) (map p (cdr ls)))))
       (define (fold-left p init ls)
	 (if (null? ls)
	     init
	     (fold-left p (p init (car ls)) (cdr ls))))
       (define (fold-right p init ls)
	 (if (null? ls)
	     init
	     (p (car ls) (fold-right p init (cdr ls))))))))

  ;; TODO: move this into the library
  (define (memq x ls)
    (cond
     ((null? ls) #f)
     ((eq? (car ls) x) ls)
     (else (memq x (cdr ls)))))

  (define (runtime-imports)
    '((scm rt-add1 (scm n))
      (scm read-char)
      (scm peek-char)
      (void write-char (scm c))
      (void error (scm where) (scm what))
      (void %log-char (scm c))
      (void %flush-log)))

  ;; TODO: The %-intrinsics should not be accessible to user code.
  (define (intrinsics)
    '((scm %read-mem base offset)
      (void %store-mem base offset val)
      (scm %get-tag v)
      (scm %set-tag v tag)
      (scm %as-fixnum v)
      (void %set-car! p car)
      (void %set-cdr! p cdr)
      (scm %unreachable)
      (scm bitwise-not x)
      (scm bitwise-and x y)
      (scm bitwise-ior x y)
      (scm bitwise-arithmetic-shift-left x bits)
      (scm bitwise-arithmetic-shift-right x bits)
      (scm eof-object)
      (scm + x y)
      (scm * x y)
      (scm - x y)
      (scm div0 x y)
      (scm mod0 x y)
      (bool eq? x y)
      (bool < x y)))

  (define (literal? x)
    (and (pair? x) (memq (car x) '(bool char number null void))))

  ;; ====================== ;;
  ;; Parsing                ;;
  ;; ====================== ;;
  (define (expand-macros-quasiquote expr)
    (cond
     ((pair? expr)
      (if (eq? (car expr) 'unquote)
	  (cons (car expr) (map expand-macros (cdr expr)))
	  (map (lambda (e) (expand-macros-quasiquote e)) expr)))
     (else expr)))
    
  (define (expand-macros expr)
    (if (pair? expr)
        (let ((tag (car expr)))
          (cond
           ((eq? tag 'quote) expr)
	   ((eq? tag 'quasiquote) (map (lambda (e) (expand-macros-quasiquote e)) expr))
           ((eq? tag 'when)
            (expand-macros `(if ,(cadr expr) (begin . ,(cddr expr)) (begin))))
           ((eq? tag 'unless)
            (expand-macros `(if ,(cadr expr) (begin) (begin . ,(cddr expr)))))
           ((eq? tag 'or)
            (if (null? (cdr expr))
                #f
                (if (null? (cddr expr))
                    (expand-macros (cadr expr))
                    (let ((t (gensym "t")))
                      `(let ((,t ,(expand-macros (cadr expr))))
                         (if ,t ,t ,(expand-macros (cons 'or (cddr expr)))))))))
           ((eq? tag 'and)
            (if (null? (cdr expr))
                #t
                (if (null? (cddr expr))
                    (expand-macros (cadr expr))
                    (let ((t (gensym "t")))
                      `(let ((,t ,(expand-macros (cadr expr))))
                         (if ,t ,(expand-macros (cons 'and (cddr expr))) #f))))))
           ((eq? tag 'not)
            `(if ,(expand-macros (cadr expr)) #f #t))
           ((eq? tag 'cond)
            (let ((clause (cadr expr))
                  (rest (cddr expr)))
              (if (eq? (car clause) 'else)
                  (expand-macros (cons 'begin (cdr clause)))
                  `(if ,(expand-macros (car clause))
                       ,(expand-macros (cons 'begin (cdr clause)))
                       ,(expand-macros (cons 'cond rest))))))
           ((eq? tag 'let*)
            (let ((bindings (cadr expr)))
              (if (null? bindings)
                  (expand-macros (cons 'begin (cddr expr)))
                  ;; bindings: ((x e) . rest)
                  (let ((x (caar bindings))
                        (e (cadar bindings))
                        (rest (cdr bindings)))
                    `(let ((,x ,(expand-macros e)))
                       ,(expand-macros `(let* ,rest . ,(cddr expr))))))))
           (else (map expand-macros expr))))
        expr))

  (define (empty-env) '())
  (define (add-env name thunk env)
    (cons (cons name thunk) env))
  (define (add-lexical name var env)
    (add-env name
             (lambda () `(var ,var))
             env))
  (define (rename-var var)
    (gensym (symbol->string var)))
  (define (lexical-refs vars)
    (map (lambda (v) `(var ,v)) vars))
  ;; Eta-expansion for by-value reference to top-level and intrinsic
  ;; definitions.
  (define (adapt-type from to expr)
    (cond
     ((eq? from to) expr)
     ((eq? from 'void) `(seq ,expr (void)))
     ((and (eq? from 'scm) (eq? to 'i32)) `(icall fixnum->i32 ,expr))
     ((and (eq? from 'i32) (eq? to 'scm)) `(icall i32->fixnum ,expr))
     ((and (eq? from 'bool) (eq? to 'scm)) `(if ,expr (bool #t) (bool #f)))
     (else
      (trace-and-error (cons from to) 'adapt-type "unhandled case"))))
  (define (add-top-level env def)
    (let ((tag (car def)))
      (unless (eq? (car def) 'define)
        (trace-and-error def 'add-top-level "unmatched top-level declaration"))
      (let ((name (caadr def)) (args (cdadr def)))
        (add-env name
                 (lambda ()
                   (let ((args (map rename-var args)))
                     `(lambda ,args (call ,name . ,(lexical-refs args)))))
                 env))))
  (define (add-intrinsic env intrinsic)
    (let ((return-type (car intrinsic))
          (name (cadr intrinsic))
          (args (cddr intrinsic)))
      (add-env name
               (lambda ()
                 (let ((args (map rename-var args)))
                   `(lambda ,args
                      ,(adapt-type
                        return-type 'scm
                        `(icall ,name . ,(lexical-refs args))))))
               env)))
  (define (add-import env import)
    (let ((return-type (car import))
          (name (cadr import))
          (arg-types (map car (cddr import)))
          (arg-names (map cadr (cddr import))))
      (add-env name
               (lambda ()
                 (let ((args (map rename-var arg-names)))
                   `(lambda ,args
                      ,(adapt-type
                        return-type 'scm
                        `(call ,name .
                               ,(map2 (lambda (expr type)
                                        (adapt-type 'scm type expr))
                                      (lexical-refs args)
                                      arg-types))))))
               env)))

  (define (add-top-levels defs env)
    (fold-left add-top-level env defs))
  (define (add-intrinsics intrinsics env)
    (fold-left add-intrinsic env intrinsics))
  (define (add-imports imports env)
    (fold-left add-import env imports))
  (define (add-lexicals vars renamed env)
    (if (null? vars)
        env
        (add-lexical (car vars) (car renamed)
                     (add-lexicals (cdr vars) (cdr renamed) env))))
  (define (lookup name env)
    (let ((pair (assq name env)))
      (unless pair
        (trace-and-error name 'lookup "unbound identifier"))
      ((cdr pair))))

  (define (map2 f l1 l2)
    (if (null? l1)
        '()
        (cons (f (car l1) (car l2)) (map2 f (cdr l1) (cdr l2)))))
  (define (make-let-bindings vars values)
    (map2 (lambda (var value) `(,var ,value)) vars values))

  (define (parse-expr expr env)
    (cond
     ((null? expr) '(null))
     ((number? expr) `(number ,expr))
     ((boolean? expr) `(bool ,expr))
     ((char? expr) `(char ,expr))
     ((string? expr)
      `(call list->string
             ,(parse-expr (cons 'quote (cons (string->list expr) '())) env)))
     ((symbol? expr) (lookup expr env))
     ((pair? expr)
      (let ((op (car expr)))
        (cond
         ((eq? op 'quote)
          (parse-expr (expand-quote (cadr expr) #f) env))
         ((eq? op 'quasiquote)
          (parse-expr (expand-quote (cadr expr) #t) env))
         ((eq? op 'if)
          (let ((t (cadr expr))
                (c (caddr expr))
                (a (cadddr expr)))
            `(if (icall eq? ,(parse-expr t env) (bool #f))
                 ,(parse-expr a env)
                 ,(parse-expr c env))))
         ((eq? op 'let)
          (let* ((vars (map car (cadr expr)))
                 (values (parse-exprs (map cadr (cadr expr)) env))
                 (vars* (map rename-var vars))
                 (bindings (make-let-bindings vars* values))
                 (body (parse-body (cddr expr)
                                   (add-lexicals vars vars* env))))
            `(let ,bindings ,body)))
         ((eq? op 'begin)
          (if (null? (cdr expr))
              '(void)
              (parse-begin (parse-expr (cadr expr) env) (cddr expr) env)))
         ((eq? op 'lambda)
          (let* ((args (cadr expr))
                 (args* (map rename-var args))
                 (body (parse-body (cddr expr)
                                   (add-lexicals args args* env))))
            `(lambda ,args* ,body)))
         (else
          `(apply-procedure . ,(parse-exprs expr env))))))
     (else
      (trace-and-error expr 'parse-expr "Unrecognized expression"))))
  (define (parse-begin head tail env)
    ;; To make the simplifier's job easier, the front-end should not
    ;; create a seq with a seq in its tail.
    (cond
     ((null? tail) head)
     ((and (pair? (car tail)) (eq? (caar tail) 'begin))
      (parse-begin head (append (cdar tail) (cdr tail)) env))
     (else
      (parse-begin `(seq (drop ,head) ,(parse-expr (car tail) env))
                   (cdr tail) env))))
  (define (parse-exprs exprs env)
    (map (lambda (expr) (parse-expr expr env)) exprs))
  (define (parse-body body env)
    (unless (pair? body) (error 'parse-body "Empty body"))
    (parse-begin (parse-expr (car body) env) (cdr body) env))
  (define (parse-function function env)
    (let ((type (car function)))
      (cond
       ((eq? 'define type)
        (let* ((name (caadr function))
	       (args (cdadr function))
	       (args* (map rename-var args))
	       (body (parse-body (cddr function)
                                 (add-lexicals args args* env))))
          `(,(cons name args*) ,body)))
       (else
        (trace-and-error
         function 'parse-function "invalid top-level declaration")))))
  (define (parse-functions functions env)
    (map (lambda (fn) (parse-function fn env)) functions))
  (define (compute-imported-functions lib imports)
    (map (lambda (import) `(%wasm-import ,lib . ,import)) imports))
  (define (parse-library lib)
    ;; For now just assume it's correctly formed. We can do error checking later.
    (let* ((body (cddr lib))     ;; skip the library and name
           (exports (cdar body)) ;; names of the functions exported
           (defs (cddr body))
           (imports (runtime-imports))
           (primitives (primitives))
           (env (add-intrinsics (intrinsics)
                                (add-imports imports (empty-env))))
           (primitives-env (add-top-levels primitives env))
           (body-env (add-top-levels defs primitives-env)))
      (cons exports
            (append (compute-imported-functions "rt" imports)
                    (append (parse-functions primitives primitives-env)
                            (parse-functions defs body-env))))))

  (define (expand-quote expr quasi)
    (cond
     ;; Literals self-evaluate
     ((or (number? expr) (boolean? expr) (char? expr) (string? expr) (null? expr))
      expr)
     ((symbol? expr)
      `(string->symbol ,(symbol->string expr)))
     ((pair? expr)
      (if (and quasi (eq? (car expr) 'unquote) (pair? (cdr expr)))
          (cadr expr)
          `(cons ,(expand-quote (car expr) quasi) ,(expand-quote (cdr expr) quasi))))
     (else
      (trace-and-error expr 'expand-quote "invalid datum"))))

  ;; ====================== ;;
  ;; Simplification         ;;
  ;; ====================== ;;

  ;; The parsing phase introduces eta-expanded lambdas for top-levels
  ;; and intrinsics, and canonicalizes "if" tests to be relop
  ;; intrinsics.  This pass simplifies away the introduced complexity
  ;; where it's not needed.

  (define (effect-free? expr)
    (or (literal? expr) (eq? (car expr) 'lambda) (eq? (car expr) 'var)))
  (define (simplify-seq head tail)
    (cond
     ((eq? (car head) 'nop) tail)
     ((eq? (car tail) 'nop) head)
     ((eq? (car tail) 'seq)
      ;; Quadratic, but shouldn't be hit normally.
      (simplify-seq (simplify-seq head (cadr tail)) (caddr tail)))
     (else `(seq ,head ,tail))))

  (define (simplify-conditional t c a)
    (or
     (and
      (eq? (car t) 'bool)
      ;; (if #t C A) -> C; (if #f C A) -> A
      (if (cadr t) c a))

     (and
      ;; (if (if TT TC TA) C A)
      (eq? (car t) 'if)
      (let ((tt (cadr t))
            (tc (caddr t))
            (ta (cadddr t)))
        (and (eq? 'bool (car tc)) (eq? 'bool (car ta))
             (cond
              ((eq? (cadr tc) (cadr ta))
               ;; (if (if TT b b) C A) -> (seq TT ,(if b C A))
               (simplify-seq (simplify-drop tt) (if (cadr tc) c a)))
              ((cadr tc)
               ;; (if (if TT #t #f) C A) -> (if TT C A)
               (simplify-conditional tt c a))
              (else
               ;; (if (if TT #f #t) C A) -> (if TT A C)
               (simplify-conditional tt a c))))))

     (and
      ;; (if (icall eq? X Y) C A)
      (eq? (car t) 'icall)
      (eq? (cadr t) 'eq?)
      (let ((x (caddr t)) (y (cadddr t)))
        (or
         (and (literal? x) (literal? y)
              ;; Fold eq? between literals.
              (if (eq? (cadr x) (cadr y)) c a))
         ;; Simplify (if (eq? X #f) #f #t) result from beta-reduction.
         (and (eq? (car x) 'if)
              (eq? (car y) 'bool) (not (cadr y))
              (let ((tft (cadr x))
                    (tfc (caddr x))
                    (tfa (cadddr x)))
                (and (eq? 'bool (car tfc)) (eq? 'bool (car tfa))
                     (cond
                      ((eq? (cadr tfc) (cadr tfa))
                       ;; (if (icall eq? (if TFT b b) #f) C A) -> (seq TFT ,(if b A C))
                       (simplify-seq (simplify-drop tft) (if (cadr tfc) a c)))
                      ((cadr tfc)
                       ;; (if (icall eq? (if TFT #t #f) #f) C A) -> (if TFT A C)
                       (simplify-conditional tft a c))
                      (else
                       ;; (if (icall eq? (if TFT #f #t) #f) C A) -> (if TFT C A)
                       (simplify-conditional tft c a)))))))))

     ;; Fallback.
     `(if ,t ,c ,a)))

  (define (simplify-drop expr)
    (if (effect-free? expr)
        '(nop)
        (let ((tag (car expr)))
          (cond
           ((eq? tag 'seq)
            (let ((head (cadr expr))
                  (tail (simplify-drop (caddr expr))))
              (if (eq? (car tail) 'nop)
                  head
                  `(seq ,head ,tail))))
           ((eq? tag 'let)
            (let ((bindings (cadr expr))
                  (body (simplify-drop (caddr expr))))
              (if (eq? (car body) 'nop)
                  ;; Convert bindings to sequence.
                  (fold-left (lambda (head expr)
                               (simplify-seq head (simplify-drop expr)))
                             '(nop)
                             (map cadr bindings))
                  `(let ,bindings ,body))))
           ((eq? tag 'if)
            `(if/void ,(cadr expr)
                      ,(simplify-drop (caddr expr))
                      ,(simplify-drop (cadddr expr))))
           ((or (eq? tag 'drop) (eq? tag 'if/void))
            (trace-and-error expr 'simplify-drop "unrecognized-expr"))
           (else
            `(drop ,expr))))))

  (define (inline-call-args vars values args)
    (cond
     ((null? args) '())
     ((null? vars) #f)
     (else
      (let ((tail (inline-call-args (cdr vars) (cdr values) (cdr args))))
        (and tail
             (eq? (caar args) 'var)
             (eq? (cadar args) (car vars))
             (cons (car values) tail))))))
  (define (inline-let vars values body)
    (and (memq (car body) '(call icall))
         (let ((inlined (inline-call-args vars values (cddr body))))
           (and inlined
                `(,(car body) ,(cadr body) . ,inlined)))))

  (define (reify-let vars values body)
    `(let ,(make-let-bindings vars values) ,body))

  (define (beta-reduce vars values body)
    ;; Many beta reductions just remove the eta-expanded top-levels
    ;; introduced in the parse phase.  In that case, the "let" is
    ;; unnecessary.  Here we have little hack to inline the "let" in
    ;; those cases..
    (if (null? vars)
        body
        (if (and (eq? (car body) 'if)
                 (literal? (caddr body))
                 (literal? (cadddr body)))
            `(if ,(beta-reduce vars values (cadr body))
                 ,(caddr body)
                 ,(cadddr body))
            (or (inline-let vars values body)
                (reify-let vars values body)))))

  (define (simplify-expr expr)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'let)
        (let* ((vars (map car (cadr expr)))
               (vals (map simplify-expr (map cadr (cadr expr))))
               (bindings (make-let-bindings vars vals))
               (body (simplify-expr (caddr expr))))
          `(let ,bindings ,body)))
       ((eq? tag 'drop)
        (simplify-drop (simplify-expr (cadr expr))))
       ((eq? tag 'seq)
        (simplify-seq (simplify-expr (cadr expr)) (simplify-expr (caddr expr))))
       ((eq? tag 'if)
        (let ((t (simplify-expr (cadr expr)))
              (c (simplify-expr (caddr expr)))
              (a (simplify-expr (cadddr expr))))
          (simplify-conditional t c a)))
       ((or (eq? tag 'call) (eq? tag 'icall))
        `(,tag ,(cadr expr) . ,(map simplify-expr (cddr expr))))
       ((eq? tag 'apply-procedure)
        (let ((target (simplify-expr (cadr expr)))
              (args (map simplify-expr (cddr expr))))
          (if (and (eq? 'lambda (car target))
                   (eq? (length (cadr target)) (length args)))
              ;; ((lambda (x ...) body) arg ...) -> (let ((x arg) ...) body)
              (beta-reduce (cadr target) args (caddr target))
              `(apply-procedure ,target . ,args))))
       ((or (eq? tag 'var) (literal? expr))
        expr)
       ((eq? tag 'lambda)
        `(lambda ,(cadr expr) ,(simplify-expr (caddr expr))))
       (else
        (trace-and-error expr 'simplify-expr "unrecognized expr")))))
  (define (simplify-function fn)
    (if (eq? (car fn) '%wasm-import)
        fn
        `(,(car fn) ,(simplify-expr (cadr fn)))))
  (define (simplify-functions functions)
    (map simplify-function functions))

  ;; ====================== ;;
  ;; Closure conversion     ;;
  ;; ====================== ;;

  ;; Closure conversion will go through a couple of passes.
  ;;
  ;; 1. annotate-free-vars - find all the lambdas and turn them into
  ;; expressions with their free variables listed at the top
  ;; level. Also lifts closure bodies.
  ;;
  ;; That's basically it for now. Later passes will lower these forms further.

  (define (convert-closures fn*)
    (let* ((bodies (cons '() '())) ; Mutated in place by annotate-free-vars.
           (result (annotate-free-vars fn* bodies)))
      (append result
              (map generate-closure-function (car bodies)))))

  (define (annotate-free-vars fn* bodies)
    (map (lambda (fn)
           (if (eq? (car fn) '%wasm-import)
               fn
               (let ((def (car fn))
                     (body (cadr fn)))
                 `(,def ,(annotate-free-vars-expr body bodies)))))
         fn*))
  (define (annotate-free-vars-expr expr bodies)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'let)
        (let ((bindings (annotate-free-vars-bindings (cadr expr) bodies))
              (body (annotate-free-vars-expr (caddr expr) bodies)))
          `(let ,bindings ,body)))
       ((eq? tag 'drop)
        `(drop ,(annotate-free-vars-expr (cadr expr) bodies)))
       ((eq? tag 'seq)
        `(seq ,(annotate-free-vars-expr (cadr expr) bodies)
              ,(annotate-free-vars-expr (caddr expr) bodies)))
       ((or (eq? tag 'if) (eq? tag 'if/void))
        `(,tag ,(annotate-free-vars-expr (cadr expr) bodies)
               ,(annotate-free-vars-expr (caddr expr) bodies)
               ,(annotate-free-vars-expr (cadddr expr) bodies)))
       ((or (eq? tag 'call) (eq? tag 'icall))
        `(,tag ,(cadr expr) . ,(annotate-free-vars-expr* (cddr expr) bodies)))
       ((eq? tag 'apply-procedure)
        `(apply-procedure . ,(annotate-free-vars-expr* (cdr expr) bodies)))
       ((or (eq? tag 'var) (eq? tag 'nop) (literal? expr))
        expr)
       ((eq? tag 'lambda)
        ;; (lambda args body) -> (make-closure args (free-vars x*) body-tag)
        (let* ((body-tag (gensym "closure-body"))
               (args (cadr expr))
               (free-vars (find-free-vars expr))
               (body (annotate-free-vars-expr (caddr expr) bodies)))
          (set-car! bodies (cons `(,body-tag ,args ,free-vars ,body) (car bodies)))
          (let ((closure-var (gensym "closure-var")))
            `(let ((,closure-var (call %alloc (number ,(closure-tag))
                                       (number ,(max 2 (+ 1 (length free-vars)))))))
               (seq ,(generate-save-free-vars
                      `(icall %store-mem (var ,closure-var) (number 0)
                              (%function-index ,body-tag))
                      closure-var free-vars 1)
                    (var ,closure-var))))))
       (else
        (trace-and-error expr 'annotate-free-vars-expr "unrecognized expr")))))
  (define (generate-save-free-vars head closure free-vars index)
    (if (null? free-vars)
	head
        (generate-save-free-vars
         `(seq ,head
               (icall %store-mem (var ,closure) (number ,(* index (word-size)))
                      (var ,(car free-vars))))
         closure (cdr free-vars) (+ 1 index))))
  (define (annotate-free-vars-bindings bindings bodies)
    (map (lambda (binding)
           `(,(car binding)
             ,(annotate-free-vars-expr (cadr binding) bodies)))
         bindings))
  (define (annotate-free-vars-expr* expr* bodies)
    (map (lambda (expr) (annotate-free-vars-expr expr bodies)) expr*))

  (define (find-free-vars expr)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'var) (cdr expr))
       ((or (literal? expr) (eq? tag 'nop)) '())
       ((eq? tag 'drop) (find-free-vars (cadr expr)))
       ((eq? tag 'seq) (find-free-vars-expr* (cdr expr)))
       ((eq? tag 'lambda)
	(set-diff (find-free-vars (caddr expr))
		  (cadr expr)))
       ((or (eq? tag 'if) (eq? tag 'if/void))
	(find-free-vars-expr* (cdr expr)))
       ((or (eq? tag 'call) (eq? tag 'icall))
	(find-free-vars-expr* (cddr expr)))
       ((eq? tag 'apply-procedure)
        (find-free-vars-expr* (cdr expr)))
       ((eq? tag 'let)
	(let ((rhs-vars (fold-left (lambda (fv binding)
				     (union fv (find-free-vars (cadr binding))))
				   '()
				   (cadr expr)))
	      (body-vars (set-diff (find-free-vars (caddr expr))
				   (map (lambda (binding) (car binding)) (cadr expr)))))
	  (union rhs-vars body-vars)))
       (else (trace-and-error expr 'find-free-vars "unrecognized expr")))))
  (define (find-free-vars-expr* expr*)
    (fold-left (lambda (free-vars expr)
		 (union free-vars (find-free-vars expr)))
	       '()
	       expr*))
  
  (define (union a b)
    (cond
     ((null? a) b)
     ((memq (car a) b) (union (cdr a) b))
     (else (cons (car a) (union (cdr a) b)))))
  (define (set-diff set sub)
    (if (null? set)
	'()
	(if (memq (car set) sub)
	    (set-diff (cdr set) sub)
	    (cons (car set) (set-diff (cdr set) sub)))))

  (define (generate-closure-function body)
    ;; (tag args free-vars body) -> (tag . body)
    (let ((closure-var (gensym "closure")))
      (let ((tag (car body))
            ;; Add an extra argument for the closure
            (args (cons closure-var (cadr body)))
            (free-vars (caddr body))
            (body (cadddr body)))
	(if (null? free-vars)
	    `((,tag . ,args) ,body)
	    `((,tag . ,args) (let ,(bind-free-vars closure-var free-vars 1)
			       ,body))))))
  (define (bind-free-vars closure free-vars index)
    (if (null? free-vars)
	'()
	(cons `(,(car free-vars)
                (icall %read-mem (icall %as-fixnum (var ,closure))
                       (number ,(* index (word-size)))))
	      (bind-free-vars closure (cdr free-vars) (+ 1 index)))))

  
  ;; ====================== ;;
  ;; Apply representation   ;;
  ;; ====================== ;;
  (define (apply-representation fn*)
    (map apply-representation-fn fn*))
  (define (apply-representation-fn fn)
    (if (eq? (car fn) '%wasm-import)
        fn
        (let ((def (car fn))
              (body (cadr fn)))
          `(,def ,(apply-representation-expr body)))))
  (define (apply-representation-expr expr)
    (unless (and (pair? expr) (symbol? (car expr)))
      (error expr 'apply-representation-expr "malformed expr"))
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'null)
        `(ptr ,(constant-null)))
       ((eq? tag 'bool)
        `(ptr ,(if (cadr expr)
                   (constant-true)
                   (constant-false))))
       ((eq? tag 'char)
        `(ptr ,(tag-constant (char->integer (cadr expr)) (char-tag))))
       ((eq? tag 'void)
        `(ptr ,(constant-void)))
       ((eq? tag 'nop)
        `(nop))
       ((eq? tag 'drop)
        `(drop ,(apply-representation-expr (cadr expr))))
       ((eq? tag 'seq)
        `(seq ,(apply-representation-expr (cadr expr))
              ,(apply-representation-expr (caddr expr))))
       ((eq? tag 'var) expr)
       ((eq? tag 'number) `(ptr ,(bitwise-arithmetic-shift-left (cadr expr) (tag-size))))
       ((or (eq? tag 'call) (eq? tag 'icall))
        (cons tag (cons (cadr expr) (map apply-representation-expr (cddr expr)))))
       ((eq? tag 'apply-procedure)
        (cons 'apply-procedure (map apply-representation-expr (cdr expr))))
       ((or (eq? tag 'if) (eq? tag 'if/void))
        `(,tag ,(apply-representation-expr (cadr expr))
               ,(apply-representation-expr (caddr expr))
               ,(apply-representation-expr (cadddr expr))))
       ((eq? tag 'let)
        `(let ,(make-let-bindings
                (map car (cadr expr))
                (map apply-representation-expr (map cadr (cadr expr))))
           ,(apply-representation-expr (caddr expr))))
       ((eq? tag '%function-index) expr)
       (else (trace-and-error
              expr 'apply-representation-expr "Unrecognized expr")))))

  ;; ====================== ;;
  ;; Compile (make wasm)    ;;
  ;; ====================== ;;
  (define (args->types args)
    (map (lambda (_) 'i32) args))
  (define (compile-icall op args env)
    (cond
     ;; FIXME: Remove seq+void when typed intrinsics work for these
     ;; three.
     ((eq? op '%set-car!)
      (let ((p (compile-expr (car args) env))
            (x (compile-expr (cadr args) env)))
        `(i32.store (offset 0)
                    (i32.and ,p (i32.const ,(fixnum-mask))) ,x)))
     ((eq? op '%set-cdr!)
      (let ((p (compile-expr (car args) env))
            (x (compile-expr (cadr args) env)))
        `(i32.store (offset ,(word-size))
                    (i32.and ,p (i32.const ,(fixnum-mask))) ,x)))
     ((eq? op '%store-mem)
      ;; (%store-mem base offset)
      `(i32.store (offset 0)
                  (i32.add (i32.and ,(compile-expr (car args) env) (i32.const ,(fixnum-mask)))
                           (i32.shr_s ,(compile-expr (cadr args) env)
                                      (i32.const ,(tag-size))))
                  . ,(if (null? (cddr args))
                         '()
                         `(,(compile-expr (caddr args) env)))))
     ((eq? op 'eof-object)
      `(i32.const ,(constant-eof)))
     ((eq? op '%unreachable)
      '(unreachable))
     ((eq? op '+)
      (let ((a (compile-expr (car args) env))
            (b (compile-expr (cadr args) env)))
        `(i32.add ,a ,b)))
     ((eq? op '-)
      `(i32.sub ,(compile-expr (car args) env)
                ,(compile-expr (cadr args) env)))
     ((eq? op '*)
      (let ((a (compile-expr (car args) env))
            (b (compile-expr (cadr args) env)))
        ;; Shift only one of them and we don't have to shift back when we're done.
        `(i32.mul (i32.shr_s ,a (i32.const ,(tag-size))) ,b)))
     ((eq? op 'div0)
      (let ((a (compile-expr (car args) env))
            (b (compile-expr (cadr args) env)))
        `(i32.shl (i32.div_s (i32.shr_s ,a (i32.const ,(tag-size)))
                             (i32.shr_s ,b (i32.const ,(tag-size))))
                  (i32.const ,(tag-size)))))
     ((eq? op 'mod0)
      (let ((a (compile-expr (car args) env))
            (b (compile-expr (cadr args) env)))
        `(i32.shl (i32.rem_s (i32.shr_s ,a (i32.const ,(tag-size)))
                             (i32.shr_s ,b (i32.const ,(tag-size))))
                  (i32.const ,(tag-size)))))
     ((eq? op 'fixnum->i32)
      `(i32.shr_s ,(compile-expr (car args) env) (i32.const ,(tag-size))))
     ((eq? op 'i32->fixnum)
      `(i32.shl ,(compile-expr (car args) env) (i32.const ,(tag-size))))
     ((eq? op '%as-fixnum)
      `(i32.and ,(compile-expr (car args) env)
                (i32.const ,(fixnum-mask))))
     ((eq? op '%set-tag)
      `(i32.or (i32.and ,(compile-expr (car args) env) (i32.const ,(fixnum-mask)))
               (i32.shr_s ,(compile-expr (cadr args) env) (i32.const ,(tag-size)))))
     ((eq? op '%get-tag)
      `(i32.shl (i32.and ,(compile-expr (car args) env) (i32.const ,(tag-mask)))
                (i32.const ,(tag-size))))
     ((eq? op '%read-mem)
      `(i32.load (offset 0) (i32.add ,(compile-expr (car args) env)
                                     (i32.shr_s ,(compile-expr (cadr args) env)
                                                (i32.const ,(tag-size))))))
     ((eq? op 'bitwise-and)
      (cons 'i32.and (compile-exprs args env)))
     ((eq? op 'bitwise-not)
      `(i32.and (i32.xor (i32.const -1) . ,(compile-exprs args env))
                (i32.const ,(fixnum-mask))))
     ((eq? op 'bitwise-ior)
      (cons 'i32.or (compile-exprs args env)))
     ((eq? op 'bitwise-arithmetic-shift-left)
      (let ((num (compile-expr (car args) env))
            (shift-amount (compile-expr (cadr args) env)))
        `(i32.shl ,num (i32.shr_s ,shift-amount (i32.const ,(tag-size))))))
     ((eq? op 'bitwise-arithmetic-shift-right)
      (let ((num (compile-expr (car args) env))
            (shift-amount (compile-expr (cadr args) env)))
        `(i32.and (i32.shr_s ,num (i32.shr_s ,shift-amount (i32.const ,(tag-size))))
                  (i32.const ,(fixnum-mask)))))
     ;; These intrinsics return 1 or 0, not Scheme #t / #f.
     ((eq? op 'zero?)
      `(i32.eqz ,(compile-expr (car args) env)))
     ((eq? op 'eq?)
      `(i32.eq ,(compile-expr (car args) env)
               ,(compile-expr (cadr args) env)))
     ((eq? op '<)
      `(i32.lt_s ,(compile-expr (car args) env)
                 ,(compile-expr (cadr args) env)))
     (else
      (trace-and-error op 'compile-icall "unrecognized intrinsic call"))))
  (define (compile-exprs exprs env)
    (map (lambda (expr) (compile-expr expr env)) exprs))
  (define (compile-expr expr env)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'nop) '(nop))
       ((eq? tag 'drop) `(drop ,(compile-expr (cadr expr) env)))
       ((eq? tag 'seq) `(seq ,(compile-expr (cadr expr) env)
                             ,(compile-expr (caddr expr) env)))
       ((eq? tag 'number) (cons 'i32.const (cdr expr)))
       ((eq? tag 'ptr) (cons 'i32.const (cdr expr)))
       ((eq? tag 'var)
        `(get-local
          ,(cdr (or (assq (cadr expr) env)
                    (trace-and-error (cons (cadr expr) env)
                                     'compile-expr "unbound local")))))
       ((eq? tag 'call)
        (cons tag (cons (cadr expr) (compile-exprs (cddr expr) env))))
       ((eq? tag 'apply-procedure)
	(let ((args (args->types (cdr expr))))
	  `(call-indirect (fn ,args (i32))
                          . ,(append (compile-exprs (cdr expr) env)
                                     `((i32.load (offset 0)
                                                 (i32.and (i32.const ,(fixnum-mask))
                                                          ,(compile-expr (cadr expr) env))))))))
       ((eq? tag 'icall)
        (compile-icall (cadr expr) (cddr expr) env))
       ((or (eq? tag 'if) (eq? tag 'if/void))
        `(,tag ,(compile-expr (cadr expr) env)
               ,(compile-expr (caddr expr) env)
               ,(compile-expr (cadddr expr) env)))
       ((eq? tag 'let)
        (let ((index (length env)))
          (compile-bindings (compile-expr (caddr expr)
                                          (bindings->env (cadr expr) env index))
                            (cadr expr) env index)))
       ((eq? tag '%function-index) expr)
       (else (trace-and-error expr 'compile-expr "unrecognized expression")))))

  (define (bindings->env bindings env index)
    (if (null? bindings)
        env
        (cons (cons (caar bindings) index)
              (bindings->env (cdr bindings) env (+ 1 index)))))
  (define (compile-bindings tail bindings env index)
    (if (null? bindings)
	tail
        (let ((val (compile-expr (cadar bindings) env))
              (init `(set-local ,index)))
          `(seq (seq ,val
                     ,(compile-bindings init (cdr bindings) env (+ 1 index)))
                ,tail))))
  (define (compile-function fn)
    (if (eq? (car fn) '%wasm-import)
        fn
        (let* ((args (number-variables (cdar fn) 0))
               (body (compile-expr (cadr fn) args)))
          `(,(max (count-locals body) (length args)) ;; Number of local variables
            ,body))))
  (define (compile-functions fn*)
    (map compile-function fn*))

  ;; Determines how many locals were used in a body.
  (define (count-locals body)
    (let ((tag (car body)))
      (cond
       ((eq? tag 'nop) 0)
       ((eq? tag 'seq)
        (max (count-locals (cadr body)) (count-locals (caddr body))))
       ((eq? tag 'call)
        (count-locals-exprs (cddr body)))
       ((eq? tag 'call-indirect)
	(count-locals-exprs (cddr body)))
       ((eq? tag 'get-local) (+ 1 (cadr body)))
       ((eq? tag 'set-local) (+ 1 (cadr body)))
       ((wasm-simple-op? tag)
        (count-locals-exprs (cdr body)))
       ((eq? tag 'i32.const) 0)
       ((eq? tag '%function-index) 0)
       ((or (eq? tag 'i32.store) (eq? tag 'i32.load))
        (count-locals-exprs (cddr body)))
       ((or (eq? tag 'if) (eq? tag 'if/void))
        (count-locals-exprs (cdr body)))
       (else (trace-and-error body 'count-locals "unrecognized expression")))))
  (define (count-locals-exprs exprs)
    (if (null? exprs)
        0
        (max (count-locals (car exprs)) (count-locals-exprs (cdr exprs)))))

  (define (number-variables vars index)
    (if (pair? vars)
        (cons (cons (car vars) index) (number-variables (cdr vars) (+ 1 index)))
        '()))

  (define (types-equal? t1* t2*)
    (if (and (pair? t1*) (pair? t2*))
        (and (eq? (car t1*) (car t2*))
             (types-equal? (cdr t1*) (cdr t2*)))
        (and (null? t1*) (null? t2*))))
  (define (type-equal? t1 t2)
    (or (eq? t1 t2)
	(and (pair? t1) (pair? t2)
             (types-equal? (cadr t1) (cadr t2))
             (types-equal? (caddr t1) (caddr t2)))))

  (define (lookup-type t types)
    (if (null? types)
	#f
	(if (type-equal? t (car types))
	    0
	    (let ((found (lookup-type t (cdr types))))
	      (if found
		  (+ 1 found)
		  #f)))))

  (define (import-arg-wasm-type type)
    (cond ((eq? type 'scm) 'i32)
          ((eq? type 'i32) 'i32)
          (else (trace-and-error type 'import-arg-wasm-type "unhandled"))))
  (define (import-return-wasm-type type)
    (cond ((eq? type 'scm) '(i32))
          ((eq? type 'i32) '(i32))
          ((eq? type 'void) '())
          (else (trace-and-error type 'import-return-wasm-type "unhandled"))))
  (define (function->type fn)
    (if (eq? (car fn) '%wasm-import)
        (let ((ret (import-return-wasm-type (caddr fn)))
              (args (map import-arg-wasm-type (map car (cdr (cdddr fn))))))
          `(fn ,args ,ret))
        ;; Scheme functions are assumed to always return an i32 and take
        ;; some number of i32s as inputs.
        `(fn ,(args->types (cdar fn)) (i32))))
  (define (functions->types fns)
    (if (null? fns)
        '()
        (let ((type (function->type (car fns)))
	      (types (functions->types (cdr fns))))
          (if (lookup-type type types)
	      types
	      (cons type types)))))
  (define (functions->type-ids fns types)
    (if (null? fns)
        '()
	(if (eq? (caar fns) '%wasm-import)
	    (functions->type-ids (cdr fns) types)
	    (cons (lookup-type (function->type (car fns)) types)
		  (functions->type-ids (cdr fns) types)))))
  (define (function->name fn)
    (if (eq? (car fn) '%wasm-import)
        (cadddr fn)
        (caar fn)))

  (define (replace-export exports name index)
    (if (null? exports)
        '()
        (let ((ex (car exports))
              (rest (replace-export (cdr exports) name index)))
          (if (or (pair? ex) (not (eq? ex name)))
              (cons ex rest)
              (cons `(fn ,index ,(symbol->string name)) rest)))))

  (define (build-exports exports functions index)
    (if (null? functions)
        exports
        (let ((fn (car functions)))
          (build-exports (replace-export exports (function->name fn) index)
                         (cdr functions)
                         (+ 1 index)))))

  (define (number-list ls i)
    (if (null? ls)
        '()
        (cons i (number-list (cdr ls) (+ 1 i)))))

  (define (wasm-simple-op? op)
    (or (eq? op 'i32.and) (eq? op 'i32.add) (eq? op 'i32.sub) (eq? op 'i32.mul)
	(eq? op 'i32.div_s) (eq? op 'i32.rem_s)
        (eq? op 'i32.or) (eq? op 'i32.xor) (eq? op 'i32.eq)
        (eq? op 'i32.lt_s) (eq? op 'i32.shr_s) (eq? op 'i32.shl) (eq? op 'drop)
        (eq? op 'unreachable)))

  (define (resolve-calls-exprs exprs env types)
    (if (null? exprs)
        '()
        (cons (resolve-calls-expr (car exprs) env types)
	      (resolve-calls-exprs (cdr exprs) env types))))
  (define (resolve-calls-expr expr env types)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'nop) expr)
       ((eq? tag 'i32.const) expr)
       ((eq? tag 'get-local) expr)
       ((eq? tag 'set-local) expr)
       ((eq? tag 'seq)
        `(seq ,(resolve-calls-expr (cadr expr) env types)
              ,(resolve-calls-expr (caddr expr) env types)))
       ((eq? tag 'call) (cons 'call (cons (index-of (cadr expr) env)
					  (resolve-calls-exprs (cddr expr) env types))))
       ((eq? tag 'call-indirect)
	(let ((type-id (lookup-type (cadr expr) types)))
	  `(call-indirect ,type-id . ,(resolve-calls-exprs (cddr expr) env types))))
       ((eq? tag '%function-index)
	`(i32.const ,(index-of (cadr expr) env)))
       ((or (eq? tag 'if) (eq? tag 'if/void))
	`(,tag
          ,(resolve-calls-expr (cadr expr) env types)
          ,(resolve-calls-expr (caddr expr) env types)
          ,(resolve-calls-expr (cadddr expr) env types)))
       ((eq? tag 'i32.store)
	(let ((offset (cadr expr))
	      (index (resolve-calls-expr (caddr expr) env types))
	      (value (resolve-calls-expr (cadddr expr) env types)))
	  `(i32.store ,offset ,index ,value)))
       ((eq? tag 'i32.load)
	(let ((offset (cadr expr))
	      (index (resolve-calls-expr (caddr expr) env types)))
	  `(i32.load ,offset ,index)))
       ((wasm-simple-op? tag)
	(let ((args (resolve-calls-exprs (cdr expr) env types)))
	  (cons tag args)))
       (else
	(trace-and-error expr 'resolve-calls-expr "unrecognized expression")))))
  (define (resolve-calls-fn function env types)

    `(,(car function) ,(resolve-calls-expr (cadr function) env types)))
  (define (resolve-calls functions env types)
    (if (null? functions)
        '()
        (if (eq? (caar functions) '%wasm-import)
            (resolve-calls (cdr functions) env types)
            (cons (resolve-calls-fn (car functions) env types)
		  (resolve-calls (cdr functions) env types)))))
  (define (gather-imports compiled-module types)
    (if (null? compiled-module)
        '()
        (let ((rest (gather-imports (cdr compiled-module) types))
              (entry (car compiled-module)))
          (if (eq? (caar compiled-module) '%wasm-import)
              (let ((module (cadr entry))
                    (name (symbol->string (cadddr entry)))
                    (type (lookup-type (function->type entry) types)))
                (cons `(,module ,name ,type) rest))
              rest))))

  ;; ====================== ;;
  ;; Wasm Binary Generation ;;
  ;; ====================== ;;
  (define (encode-sleb n)
    (if (let ((n* (+ n 64)))
          (eq? n* (bitwise-and n* #x7f)))
        `(,(bitwise-and n #x7f))
        (cons (bitwise-ior #x80 (bitwise-and n #x7f))
              (encode-sleb (bitwise-arithmetic-shift-right n 7)))))
  (define (encode-uleb n)
    (let ((next (bitwise-arithmetic-shift-right n 7)))
      (if (zero? next)
          `(,n)
          (cons (bitwise-ior #x80 (bitwise-and n #x7f))
                (encode-uleb next)))))

  (define (encode-string s)
    (let ((chars (string->list s)))
      (make-vec (length chars) (map char->integer chars))))

  (define (wasm-header)
    '(#x00 #x61 #x73 #x6d #x01 #x00 #x00 #x00))

  (define (make-vec length contents)
    (cons (encode-uleb length) contents))

  ;; id is the number, contents is a list of bytes
  (define (byte-count ls)
    (cond
     ((pair? ls) (+ (byte-count (car ls)) (byte-count (cdr ls))))
     ((null? ls) 0)
     (else 1)))
  (define (make-section id contents)
    (cons id (make-vec (byte-count contents) contents)))

  (define (encode-type type)
    (cond
     ((eq? type 'i32) '(#x7f))
     ((eq? type 'i64) '(#x7e))
     ((eq? type 'f32) '(#x7d))
     ((eq? type 'f64) '(#x7c))
     ((eq? type 'void) '(#x40))
     ;; functions are (fn (t1 ...) (t2 ...)), for t1 ... -> t2 ...
     ((and (pair? type) (eq? (car type) 'fn))
      (cons #x60 (cons (encode-type-vec (cadr type)) (encode-type-vec (caddr type)))))
     (else (trace-and-error type 'encode-type "unrecognized type"))))
  (define (encode-type-vec types)
    (make-vec (length types) (map encode-type types)))
  (define (wasm-type-section types)
    (make-section 1 (encode-type-vec types)))

  (define (encode-import import)
    (let ((module (car import))
          (name (cadr import)))
      (cons (encode-string module)
            (cons (encode-string name)
                  (cons '(#x00) (encode-uleb (caddr import)))))))
  (define (encode-memory-import)
    (cons (encode-string "memory")
          (cons (encode-string "memory")
                ;; Import a memory with at least 1 page and no maximum.
                '(#x02 #x00 #x01))))
  (define (wasm-import-section imports)
    ;; Add 1 to the length because we import a memory too.
    (make-section 2 (make-vec (+ (length imports) 1)
                              (append (map encode-import imports)
                                      (encode-memory-import)))))

  (define (encode-u32-vec nums)
    (make-vec (length nums) (map encode-uleb nums)))

  (define (wasm-function-section function-type-ids)
    (make-section 3 (encode-u32-vec function-type-ids)))

  (define (encode-export export)
    (cond
     ((eq? (car export) 'fn)
      (cons (encode-string (caddr export)) (cons #x00 (encode-uleb (cadr export)))))
     (else
      (trace-and-error export 'encode-export "unrecognized export"))))
  (define (wasm-export-section exports)
    (make-section 7 (make-vec (length exports) (map encode-export exports))))

  (define (encode-simple-op op expr)
    (cons (map encode-expr (cdr expr)) op))

  (define (encode-expr expr)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'seq)
        (cons (encode-expr (cadr expr)) (encode-expr (caddr expr))))
       ((eq? tag 'i32.const)
        (cons #x41 (encode-sleb (cadr expr))))
       ((eq? tag 'i32.eqz)
        (cons (encode-expr (cadr expr)) '(#x45)))
       ((eq? tag 'i32.eq)
        (encode-simple-op #x46 expr))
       ((eq? tag 'i32.lt_s)
        (encode-simple-op #x48 expr))
       ((eq? tag 'get-local)
        (cons #x20 (encode-uleb (cadr expr))))
       ((eq? tag 'set-local)
	(cons #x21 (encode-uleb (cadr expr))))
       ((eq? tag 'call)
        (cons (map encode-expr (cddr expr))
              (cons #x10 (encode-uleb (cadr expr)))))
       ((eq? tag 'call-indirect)
	`(,(map encode-expr (cddr expr))
	  (#x11 ,(encode-uleb (cadr expr)) #x00)))
       ((or (eq? tag 'if) (eq? tag 'if/void))
        (let ((type (if (eq? tag 'if) 'i32 'void))
              (t (cadr expr))
              (c (caddr expr))
              (a (cadddr expr)))
          (cons (encode-expr t)
                (cons #x04 (cons (encode-type type)
                                 (cons (encode-expr c)
                                       (cons #x05 (cons (encode-expr a) '(#x0b)))))))))
       ((eq? tag 'i32.store)
        (let ((align 0)
              (offset (cadadr expr))
              (index (encode-expr (caddr expr)))
              (value (encode-expr (cadddr expr))))
          (cons (cons index value)
                (cons '(#x36 #x0) ;;always use 0 alignment
                      (encode-uleb offset)))))
       ((eq? tag 'i32.load)
        (let ((align 0)
              (offset (cadadr expr))
              (index (encode-expr (caddr expr))))
          (cons index (cons '(#x28 #x0) ;;always use 0 alignment
                            (encode-uleb offset)))))
       ((eq? tag 'i32.add)
        (encode-simple-op #x6a expr))
       ((eq? tag 'i32.sub)
        (encode-simple-op #x6b expr))
       ((eq? tag 'i32.mul)
        (encode-simple-op #x6c expr))
       ((eq? tag 'i32.div_s)
        (encode-simple-op #x6d expr))
       ((eq? tag 'i32.rem_s)
        (encode-simple-op #x6f expr))
       ((eq? tag 'i32.and)
        (encode-simple-op #x71 expr))
       ((eq? tag 'i32.or)
        (encode-simple-op #x72 expr))
       ((eq? tag 'i32.xor)
        (encode-simple-op #x73 expr))
       ((eq? tag 'i32.shl)
        (encode-simple-op #x74 expr))
       ((eq? tag 'i32.shr_s)
        (encode-simple-op #x75 expr))
       ((eq? tag 'nop)
	'())
       ((eq? tag 'drop)
	(encode-simple-op #x1a expr))
       ((eq? tag 'unreachable)
        (encode-simple-op #x00 expr))
       (else
        (trace-and-error expr 'encode-expr "unrecognized expr")))))

  (define (encode-code locals body)
    (let ((contents (cons
                     (if (zero? locals)
                         (make-vec 0 '())
                         (make-vec 1 (cons (encode-uleb locals) '(#x7f))))
                     (cons (encode-expr body)
                           '(#x0b)))))
      (make-vec (byte-count contents) contents)))
  (define (encode-codes codes)
    (map (lambda (code) (encode-code (car code) (cadr code))) codes))
  (define (wasm-code-section codes)
    (make-section 10 (make-vec (length codes) (encode-codes codes))))

  (define (wasm-name-section names)
    (make-section 0 (cons (encode-string "name")
                          (make-section 1 ;; 1 for function name subsection
                                        (make-vec (length names)
                                                  (encode-name-maps names 0))))))
  (define (encode-name-maps names index)
    (if (null? names)
        '()
        (cons (cons (encode-uleb index)
                    (encode-string (symbol->string (car names))))
              (encode-name-maps (cdr names) (+ 1 index)))))

  (define (wasm-table-section num-items)
    (make-section 4 (make-vec 1
			      `(#x70 #x00 . ,(encode-uleb num-items)))))

  (define (encode-numbers numbers)
    (if (null? numbers)
	'()
	(cons (encode-uleb (car numbers)) (encode-numbers (cdr numbers)))))
  (define (wasm-element-section element-ids)
    (make-section 9 (make-vec 1 `(0 ,(encode-expr `(i32.const 0))
				    #x0b
				    ,(make-vec (length element-ids)
					       (encode-numbers element-ids))))))

  ;; Takes a library and returns a list of the corresponding Wasm module
  ;; bytes
  (define (compile-library library)
    (generate-module-from-package (compile-library->module-package library)))
  (define (compile-library->module-package library)
    ;; (parsed-lib : (exports . functions)
    (let ((parsed-lib (parse-library (expand-macros library))))
      (let ((exports (car parsed-lib)))
        (let* ((simplified (simplify-functions (cdr parsed-lib)))
               (closure-converted (convert-closures simplified))
               (function-names (map function->name closure-converted))
               (types (functions->types closure-converted))
	       (type-ids (functions->type-ids closure-converted types))
               (compiled-module (compile-functions
                                 (apply-representation closure-converted))))
          (let ((exports (build-exports exports closure-converted 0))
                (imports (gather-imports compiled-module types)))
            `(,types ,exports ,imports ,compiled-module ,function-names ,type-ids))))))
  (define (generate-module-from-package package)
    (let ((types (car package))
          (exports (cadr package))
          (imports (caddr package))
          (compiled-module (cadddr package))
          (function-names (cadddr (cdr package)))
	  (type-ids (cadddr (cddr package))))
      (let ((functions (resolve-calls compiled-module function-names types)))
	(generate-module types exports imports functions function-names type-ids))))
  (define (generate-module types exports imports functions function-names type-ids)
    (cons (wasm-header)
          (cons (cons (wasm-type-section types)
                      (cons (wasm-import-section imports)
                            (cons (wasm-function-section type-ids)
                                  (cons (wasm-table-section (length function-names))
					(cons (wasm-export-section exports)
					      (cons (wasm-element-section
						     (number-list function-names 0))
						    (wasm-code-section functions)))))))
                (wasm-name-section function-names))))

  (define (write-bytes ls)
    (cond
     ((null? ls) #t)
     ((number? ls) (write-char (integer->char ls)))
     (else
      (write-bytes (car ls))
      (write-bytes (cdr ls)))))
  (define (compile-stdin->module-package)
    (compile-library->module-package (read)))
  (define (compile-module-package->stdout package)
    (write-bytes (generate-module-from-package package)))
  (define (compile-stdin->stdout)
    (compile-module-package->stdout (compile-library->module-package (read)))))
