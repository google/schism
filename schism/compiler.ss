;; Copyright 2018 Google LLC
;;
;; Licensed under the Apache License, Version 2.0 (the License);
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an AS IS BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.

(library (schism compiler)
  (export compile-library compile-stdin->stdout)
  (import (rnrs)
          (only (chezscheme) gensym))
  (define (tag-size) 3)
  (define (fixnum-mask) -8) ;; a magic mask that turns ptrs into fixnums
  (define (tag-mask) 7)
  (define (tag-constant value tag)
    (bitwise-ior (bitwise-arithmetic-shift-left value (tag-size)) tag))
  ;; fixnums are 0 so most arithmetic doesn't require shifting
  (define (fixnum-tag) 0)
  ;; constant-tag is used for implementation constants, such as #f, #t and ()
  (define (constant-tag) 1)
  (define (constant-false) (tag-constant 0 (constant-tag)))
  (define (constant-true) (tag-constant 1 (constant-tag)))
  (define (constant-null) (tag-constant 2 (constant-tag)))
  (define (constant-eof) (tag-constant 3 (constant-tag)))
  (define (constant-void) (tag-constant 4 (constant-tag)))
  (define (pair-tag) 2)
  (define (char-tag) 3)
  (define (string-tag) 4)
  (define (symbol-tag) 5)
  (define (closure-tag) 6)

  (define (allocation-pointer) 0)
  (define (word-size) 4)

  ;; ====================== ;;
  ;; Helpers, etc.          ;;
  ;; ====================== ;;
  (define (trace-value x)
    (let ((_ (write x)))
      (let ((_ (newline)))
        x)))

  (define (index-of-helper x ls index)
    (if (pair? ls)
        (if (eq? x (car ls))
            index
            (index-of-helper x (cdr ls) (+ 1 index)))
        (let ((_ (display x)))
          (let ((_ (newline)))
            (error 'index-of "Could not find item")))))
  (define (index-of x ls)
    (index-of-helper x ls 0))

  (define (primitives)
    (expand-macros
     `((%wasm-import "rt" (rt-add1 n))
       (%wasm-import "rt" (read-char))
       (%wasm-import "rt" (peek-char))
       (%wasm-import "rt" (write-char c))
       (%wasm-import "rt" (error where what))
       (%wasm-import "rt" (%log-char c))
       (%wasm-import "rt" (%flush-log))
       ;; display, newline, etc are all just enough to compile. We'll fill them in later.
       (define (display x)
         (cond
          ((pair? x)
           (begin (%display-raw-string "(")
                  (display (car x))
                  (%display-pair-tail (cdr x))))
          ((null? x)
           (%display-raw-string "()"))
          ((symbol? x) (%display-raw-string (symbol->string x)))
          ((boolean? x) (%display-raw-string (if x "#t" "#f")))
          ((number? x) (begin (%display-leading-digits x) (%display-least-significant-digit x)))
          ((char? x) (begin (%log-char #\#) (%log-char #\\) (%log-char x)))
          ((string? x) (begin (%log-char #\") (%display-raw-string x) (%log-char #\")))
          (else (%display-raw-string "<!display unknown unimplemented!>"))))
       (define (%display-leading-digits n)
         (if (zero? n)
             (begin)
             (begin (%display-leading-digits (/ n 10))
                    (%display-least-significant-digit n))))
       (define (%display-least-significant-digit n)
         (let ((n (- n (* 10 (/ n 10))))) ;; apparently we don't support mod yet
           (%log-char (integer->char (+ (char->integer #\0) n)))))
       (define (%display-pair-tail x)
         (cond
          ((null? x) (%display-raw-string ")"))
          ((pair? x) (begin (%display-raw-string " ")
                            (display (car x))
                            (%display-pair-tail (cdr x))))
          (else (begin (%display-raw-string " . ")
                       (display x)
                       (%display-raw-string ")")))))
       (define (%display-raw-string s)
         (if (string? s)
             (%display-chars-as-string (string->list s))
             (error '%display-raw-string "not a string")))
       (define (%display-chars-as-string chars)
         (cond
          ((null? chars) (begin))
          ((pair? chars) (begin (%log-char (car chars))
                                (%display-chars-as-string (cdr chars))))
          (else (error '%display-chars-as-string "not a list of chars"))))
       (define (write x)
         (if (string? x)
             (%display-raw-string x)
             (display x)))
       (define (newline)
         (%flush-log))
       (define (%base-pair) (%set-tag ,(allocation-pointer) ,(pair-tag)))
       (define (%symbol-table) (cdr (%base-pair)))
       (define (%alloc tag num-words)
         (let ((new-pointer (+ (* ,(word-size) num-words) (car (%base-pair)))))
           (begin
             (set-car! (%base-pair) new-pointer)
             ;; We have an unstated assumption that we always allocate at least 8 bytes.
             ;; Add two words to offset for base-pair.
             (%set-tag (+ new-pointer ,(* 2 (word-size))) tag))))
       (define (cons a d)
         (init-pair (%alloc ,(pair-tag) 2) a d))
       (define (set-car! p a)
         (if (pair? p)
             (%set-car! p a)
             (error 'set-car! "set-car!: not a pair")))
       (define (set-cdr! p d)
         (if (pair? p)
             (%set-cdr! p d)
             (error 'set-cdr! "set-cdr!: not a pair")))
       (define (init-pair p a d)
         (set-car! p a)
         (set-cdr! p d)
         p)
       (define (car p)
         (if (pair? p)
             (read-ptr p 0)
             (error 'car "car: not a pair")))
       (define (cdr p)
         (if (pair? p)
             (read-ptr p ,(word-size))
             (error 'cdr "cdr: not a pair")))
       (define (caar p) (car (car p)))
       (define (cadr p) (car (cdr p)))
       (define (cdar p) (cdr (car p)))
       (define (cddr p) (cdr (cdr p)))
       (define (caaar p) (car (caar p)))
       (define (caadr p) (car (cadr p)))
       (define (cadar p) (car (cdar p)))
       (define (cddar p) (cdr (cdar p)))
       (define (caddr p) (car (cddr p)))
       (define (cdadr p) (cdr (cadr p)))
       (define (cdddr p) (cdr (cddr p)))
       (define (caadar p) (car (cadar p)))
       (define (caaddr p) (car (caddr p)))
       (define (caddar p) (car (cddar p)))
       (define (cadadr p) (car (cdadr p)))
       (define (cadddr p) (car (cdddr p)))
       (define (cdaddr p) (cdr (caddr p)))
       (define (assq x ls)
         (if (pair? ls)
             (if (eq? x (caar ls))
                 (car ls)
                 (assq x (cdr ls)))
	     (if (null? ls)
		 #f
		 (begin (display x) (newline) (error 'assq "not a list")))))
       (define (length ls)
         (cond
          ((null? ls) 0)
          ((pair? ls) (+ 1 (length (cdr ls))))
          (else (error 'length "argument is not a proper list"))))
       (define (append a b)
         (if (null? a) b (cons (car a) (append (cdr a) b))))
       (define (read-ptr p offset)
         (%read-mem (%as-fixnum p) offset))
       (define (char->integer c) (%as-fixnum c)) ;; TODO: check tag
       (define (integer->char c) (%set-tag c ,(char-tag)))
       (define (char-between c c1 c2) ;; inclusive
         (if (char-ci<? c c1)
             #f
             (if (char-ci<? c c2)
                 #t
                 (if (eq? c c2) #t #f))))
       (define (char-numeric? c)
         (char-between c #\0 #\9))
       (define (char-whitespace? c)
         (or (eq? c #\space) (eq? c #\tab) (eq? c #\newline)))
       (define (char-hex? c)
         (or (char-numeric? c) (char-between c #\a #\f)))
       (define (char-ci<? c1 c2)
         (< (char->integer c1) (char->integer c2)))
       (define (list->string ls)
         (if (pair? ls)
             ;; For now we represent strings as lists of characters. That
             ;; means converting between the two is just a matter of
             ;; changing the tags.
             (%set-tag ls ,(string-tag))
             (error 'list->string "list->string: not a pair")))
       (define (string->list s)
         (if (string? s)
             (%set-tag s ,(pair-tag))
             ;; calling error here can lead to an infinite loop, so we
             ;; generate an unreachable instead.
             (%unreachable)))
       (define (string-equal? s1 s2)
         (list-all-eq? (string->list s1) (string->list s2)))
       (define (%find-symbol-by-name s table)
         (if (or (zero? table) (null? table))
             #f
             (if (pair? table)
                 ;; (car table) is not a string in the case of gensyms
                 (if (and (string? (car table)) (string-equal? s (car table)))
                     (%set-tag table ,(symbol-tag))
                     (%find-symbol-by-name s (cdr table)))
                 (error '%find-symbol-by-name "corrupt symbol table"))))
       (define (string->symbol s)
         (if (string? s)
             (or (%find-symbol-by-name s (%symbol-table))
                 (let ((x (cons s (%symbol-table))))
                   (begin
                     (set-cdr! (%base-pair) x)
                     (%set-tag x ,(symbol-tag)))))
             ;; calling error here can lead to an infinite loop, so we
             ;; generate an unreachable instead.
             (%unreachable)))
       (define (gensym t) ;; Creates a brand new symbol that cannot be reused
         (let ((x (cons '() (%symbol-table))))
           (begin (set-cdr! (%base-pair) x)
                  (%set-tag x ,(symbol-tag)))))
       (define (symbol->string x)
         (if (symbol? x)
             (let ((s (car (%set-tag x ,(pair-tag)))))
               (if (null? s) "<gensym>" s))
             (error 'symbol->string "not a symbol")))
       (define (list-all-eq? a b)
         (if (null? a)
             (null? b)
             (and (not (null? b))
                  (eq? (car a) (car b))
                  (list-all-eq? (cdr a) (cdr b)))))
       (define (< a b)
         (if (< a b) #t #f))
       (define (> a b)
         (< b a))
       (define (max a b)
         (if (< a b) b a))
       (define (read)
         (let ((_ (read-skip-whitespace-and-comments)))
           (start-read (read-char))))
       (define (start-read c)
         (cond
          ((char-numeric? c)
           (read-number (- (char->integer c) (char->integer #\0))))
          ((and (eq? c #\-) (char-numeric? (peek-char)))
           (- 0 (read-number 0)))
          ((eq? c #\#)
           (read-hash (read-char)))
          ((eq? c #\()
           (read-list))
          ((eq? c #\')
           (cons 'quote (cons (read) '())))
          ((eq? c #\`)
           (cons 'quasiquote (cons (read) '())))
          ((eq? c #\,)
           (cons 'unquote (cons (read) '())))
          ((eq? c #\")
           (list->string (read-string)))
          ((char-symbolic? c)
           (string->symbol (list->string (cons c (read-symbol)))))
          (else
           (error 'start-read "malformed datum"))))
       (define (read-string)
         (let ((c (read-char)))
           (if (eq? c #\")
               '()
               (cons c (read-string)))))
       (define (char-symbolic? c)
         (not (or (char-whitespace? c) (eq? c #\() (eq? c #\)) (eq? c #\;))))
       (define (read-symbol)
         (if (char-symbolic? (peek-char))
             (cons (read-char) (read-symbol))
             '()))
       (define (read-list)
         (read-skip-whitespace-and-comments)
         (cond
          ((eq? (peek-char) #\))
           (begin (read-char) '()))
          ((eq? (peek-char) #\.)
           (begin (read-char)
                  (let ((d (read)))
                    (begin (read-skip-whitespace-and-comments)
                           (if (eq? (read-char) #\))
                               d
                               (error 'read-list "invalid improper list"))))))
          (else
           (let ((a (read)))
             (let ((d (read-list)))
               (cons a d))))))
       (define (read-skip-whitespace-and-comments)
         (if (char-whitespace? (peek-char))
             (let ((_ (read-char)))
               (read-skip-whitespace-and-comments))
             (if (eq? (peek-char) #\;)
                 (read-skip-line)
                 #f)))
       (define (read-skip-line)
         (if (eq? (peek-char) #\newline)
             (read-skip-whitespace-and-comments)
             (let ((_ (read-char)))
               (read-skip-line))))
       (define (read-number acc)
         (if (char-numeric? (peek-char))
             (read-number (+ (* acc 10) (- (char->integer (read-char))
                                           (char->integer #\0))))
             acc))
       (define (hex-digit c)
         (if (char-numeric? c)
             (- (char->integer c)
                (char->integer #\0))
             (+ 10 (- (char->integer c)
                      (char->integer #\a)))))
       (define (read-hex acc)
         (if (char-hex? (peek-char))
             (read-hex (+ (* acc 16) (hex-digit (read-char))))
             acc))
       (define (read-hash c)
         (cond
          ((eq? c #\f)
           #f)
          ((eq? c #\t)
           #t)
          ((eq? c #\\)
           (let ((c (read-char)))
             (cond
              ((and (eq? c #\s) (eq? (peek-char) #\p)) ;; check if this is a space
               (let ((p (read-char)) (a (read-char)) (c (read-char)) (e (read-char)))
                 #\space))
              ((and (eq? c #\t) (eq? (peek-char) #\a)) ;; check if this is a tab
               (let ((a (read-char)) (b (read-char)))
                 #\tab))
              ((and (eq? c #\n) (eq? (peek-char) #\e)) ;; check if this is a newline
               (let ((e (read-char)) (w (read-char)) (l (read-char)) (i (read-char))
                     (n (read-char)) (e^ (read-char)))
                 #\newline))
              (else c))))
          ((eq? c #\x)
           (read-hex 0))
          (else #f)))
       (define (eq? a b)
         (if (eq? a b) #t #f))
       (define (zero? n)
         (eq? n 0))
       (define (null? x)
         (eq? x '()))
       (define (pair? p)
         (eq? (%get-tag p) ,(pair-tag)))
       (define (boolean? p)
         (or (eq? p #t) (eq? p #f)))
       (define (number? p)
         (eq? (%get-tag p) ,(fixnum-tag)))
       (define (char? p)
         (eq? (%get-tag p) ,(char-tag)))
       (define (string? p)
         (eq? (%get-tag p) ,(string-tag)))
       (define (symbol? p)
         (eq? (%get-tag p) ,(symbol-tag)))
       (define (procedure? p)
         (eq? (%get-tag p) ,(closure-tag))))))

  ;; TODO: move this into the library
  (define (memq x ls)
    (cond
     ((null? ls) #f)
     ((eq? (car ls) x) ls)
     (else (memq x (cdr ls)))))

  (define (intrinsic? x)
    (memq x '(%read-mem %store-mem %get-tag %set-tag %as-fixnum bitwise-and
                        bitwise-not bitwise-ior bitwise-arithmetic-shift-left
                        bitwise-arithmetic-shift-right eof-object + * - / %set-car!
                        %set-cdr! %unreachable)))

  (define (relop? x)
    (memq x '(eq? neq? <)))

  (define (literal? x)
    (and (pair? x) (memq (car x) '(bool char number null))))

  ;; ====================== ;;
  ;; Parsing                ;;
  ;; ====================== ;;
  (define (lookup x env)
    (cdr (assq x env)))

  (define (expand-macros expr)
    (if (pair? expr)
        (let ((tag (car expr)))
          (cond
           ((or (eq? tag 'quote) (eq? tag 'quasiquote)) expr)
           ((eq? tag 'or)
            (if (null? (cdr expr))
                #f
                (if (null? (cddr expr))
                    (expand-macros (cadr expr))
                    (let ((t (gensym "t")))
                      `(let ((,t ,(expand-macros (cadr expr))))
                         (if ,t ,t ,(expand-macros (cons 'or (cddr expr)))))))))
           ((eq? tag 'and)
            (if (null? (cdr expr))
                #t
                (if (null? (cddr expr))
                    (expand-macros (cadr expr))
                    (let ((t (gensym "t")))
                      `(let ((,t ,(expand-macros (cadr expr))))
                         (if ,t ,(expand-macros (cons 'and (cddr expr))) #f))))))
           ((eq? tag 'not)
            `(if ,(expand-macros (cadr expr)) #f #t))
           ((eq? tag 'cond)
            (let ((clause (cadr expr))
                  (rest (cddr expr)))
              (if (eq? (car clause) 'else)
                  (expand-macros (cadr clause))
                  `(if ,(expand-macros (car clause))
                       ,(expand-macros (cadr clause))
                       ,(expand-macros (cons 'cond rest))))))
           ((eq? tag 'let*)
            (let ((bindings (cadr expr)))
              (if (null? bindings)
                  (expand-macros (caddr expr))
                  ;; bindings: ((x e) . rest)
                  (let ((x (caar bindings))
                        (e (cadar bindings))
                        (rest (cdr bindings)))
                    `(let ((,x ,(expand-macros e)))
                       ,(expand-macros `(let* ,rest ,(caddr expr))))))))
           (else (expand-macros* expr))))
        expr))
  (define (expand-macros* exprs)
    (if (null? exprs)
        '()
        (cons (expand-macros (car exprs)) (expand-macros* (cdr exprs)))))

  (define (parse-exprs exprs env)
    (if (null? exprs)
        '()
        (cons (parse-expr (car exprs) env) (parse-exprs (cdr exprs) env))))
  (define (parse-expr expr env)
    (cond
     ((null? expr) '(null))
     ((number? expr) `(number ,expr))
     ((boolean? expr) `(bool ,expr))
     ((char? expr) `(char ,expr))
     ((string? expr)
      `(call list->string ,(parse-expr (cons 'quote (cons (string->list expr) '())) env)))
     ((symbol? expr) `(var ,expr))
     ((pair? expr)
      (let ((op (car expr)))
        (cond
         ((eq? op 'quote)
          (parse-expr (expand-quote (cadr expr) #f) env))
         ((eq? op 'quasiquote)
          (parse-expr (expand-quote (cadr expr) #t) env))
         ((eq? op 'if)
          (let ((t (cadr expr))
                (c (caddr expr))
                (a (cadddr expr)))
            `(if ,(parse-pred t env) ,(parse-expr c env) ,(parse-expr a env))))
         ((eq? op 'let)
          (let ((bindings (parse-bindings (cadr expr) env))
                (body (parse-expr (caddr expr)
                                  (extend-parse-env (let-binding-names (cadr expr)) env))))
            `(let ,bindings ,body)))
         ((eq? op 'begin)
          (cons 'begin (parse-exprs (cdr expr) env)))
         ((eq? op 'lambda)
          (let ((args (cadr expr))
                (body (caddr expr))) ;; for now allow single-expression bodies
            `(lambda ,args ,(parse-expr body env))))
         ((intrinsic? op)
          (cons op (parse-exprs (cdr expr) env)))
         (else
          ;; this is a function call
	  (let ((target (car expr)))
	    (if (symbol? target)
		(let ((type (lookup target env)))
		  (if (eq? type 'top-level)
		      (cons 'call (cons (car expr) (parse-exprs (cdr expr) env)))
		      (error 'parse-expr
			     "only top-level function calls are currently supported")))
		(error 'parse-expr "only direct, top-level calls are currently supported")))))))
     (else
      (let ((_ (display expr)))
        (let ((_ (newline)))
          (error 'parse-expr "Unrecognized expression"))))))
  (define (parse-pred expr env)
    (cond
     ((boolean? expr) `(bool ,expr))
     ((pair? expr)
      (let ((op (car expr)))
        (cond
         ((eq? op 'eq?)
          `(eq? ,(parse-expr (cadr expr) env) ,(parse-expr (caddr expr) env)))
         ((eq? op '<)
          `(< ,(parse-expr (cadr expr) env) ,(parse-expr (caddr expr) env)))
         (else
          `(neq? ,(parse-expr expr env) ,(parse-expr #f env))))))
     (else
      `(neq? ,(parse-expr expr env) ,(parse-expr #f env)))))
  (define (parse-bindings bindings env)
    (if (null? bindings)
        '()
        (let ((var (caar bindings))
              (value (parse-expr (cadar bindings) env)))
          (cons `(,var ,value) (parse-bindings (cdr bindings) env)))))
  (define (parse-body* body* env)
    (if (null? body*)
        '()
        (cons (parse-expr (car body*) env) (parse-body* (cdr body*) env))))
  (define (parse-body body env)
    ;; expr ... -> (begin expr ...)
    (cons 'begin (parse-body* body env)))
  (define (parse-function function env)
    (let ((type (car function)))
      (cond
       ((eq? 'define type)
        (let* ((name (caadr function))
	       (args (cdadr function))
	       (body (parse-body (cddr function) (extend-parse-env args env))))
          `(,(cons name args) ,body)))
       ((eq? '%wasm-import type)
        function)
       (else
        (let ((_ (display function)))
          (let ((_ (newline)))
            (error 'parse-function "invalid top-level declaration")))))))
  (define (parse-functions functions env)
    (if (null? functions)
        '()
        (cons (parse-function (car functions) env) (parse-functions (cdr functions) env))))
  (define (parse-library lib)
    ;; For now just assume it's correctly formed. We can do error checking later.
    (let ((body (cddr lib)))      ;; skip the library and name
      (let* ((exports (cdar body)) ;; names of the functions exported
             (functions (append (primitives) (cddr body)))
             (env (make-parse-environment functions))
             (functions (parse-functions functions env)))
        (cons exports functions))))

  (define (make-parse-environment functions)
    ;; Extract top-level function names
    (if (null? functions)
        '()
        (let ((rest (make-parse-environment (cdr functions)))
              (name (cond
                     ((eq? (caar functions) 'define)
<<<<<<< HEAD
                      ;; TODO: replace this with caadar once the next snapshot lands
                      (caadr (car functions)))
                     ((eq? (caar functions) '%wasm-import)
                      (car (caddar functions)))
                     (else (error 'make-parse-environment "unmatched top level declaration")))))
          `((,name . top-level) . ,rest))))
=======
                      (caadar functions))
                     ((eq? (caar functions) '%wasm-import)
                      (car (caddar functions)))
                     (else (error 'make-parse-environment "unmatched top level declaration")))))
          (cons (cons name 'top-level) rest))))
>>>>>>> 5d140f837b960fcf7f66aeccc75c1b631bdc1aa1
  (define (let-binding-names bindings)
    (if (null? bindings)
        '()
        (cons (caar bindings) (let-binding-names (cdr bindings)))))
  (define (extend-parse-env vars env)
    (if (null? vars)
        env
        (cons (cons (car vars) 'local) (extend-parse-env (cdr vars) env))))

  (define (expand-quote expr quasi)
    (cond
     ;; Literals self-evaluate
     ((or (number? expr) (boolean? expr) (char? expr) (string? expr) (null? expr))
      expr)
     ((symbol? expr)
      `(string->symbol ,(symbol->string expr)))
     ((pair? expr)
      (if (and quasi (eq? (car expr) 'unquote) (pair? (cdr expr)))
          (cadr expr)
          `(cons ,(expand-quote (car expr) quasi) ,(expand-quote (cdr expr) quasi))))
     (else
      (let ((_ (trace-value expr)))
        (error 'expand-quote "invalid datum")))))

  (define (args->types args)
    (if (null? args)
        '()
        (cons 'i32 (args->types (cdr args)))))

  ;; ====================== ;;
  ;; Closure conversion     ;;
  ;; ====================== ;;

  ;; Closure conversion will go through a couple of passes.
  ;;
  ;; 1. annotate-free-vars - find all the lambdas and turn them into
  ;; expressions with their free variables listed at the top
  ;; level. Also lifts closure bodies.
  ;;
  ;; That's basically it for now. Later passes will lower these forms further.

  (define (convert-closures fn*)
    (let ((bodies (cons '() '())))
      (let ((result (annotate-free-vars fn* bodies)))
        (let ((generated-functions (generate-closure-functions (car bodies))))
          (begin
            (append generated-functions result))))))

  (define (annotate-free-vars fn* bodies)
    (if (null? fn*)
        '()
        (cons (annotate-free-vars-fn (car fn*) bodies) (annotate-free-vars (cdr fn*) bodies))))
  (define (annotate-free-vars-fn fn bodies)
    (if (eq? (car fn) '%wasm-import)
        fn
        (let ((def (car fn))
              (body (cadr fn)))
          `(,def ,(annotate-free-vars-expr body bodies)))))
  (define (annotate-free-vars-expr expr bodies)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'let)
        (let ((bindings (annotate-free-vars-bindings (cadr expr) bodies))
              (body (annotate-free-vars-expr (caddr expr) bodies)))
          `(let ,bindings ,body)))
       ((eq? tag 'begin)
        (cons 'begin (annotate-free-vars-expr* (cdr expr) bodies)))
       ((eq? tag 'if)
        `(if ,(annotate-free-vars-expr (cadr expr) bodies)
             ,(annotate-free-vars-expr (caddr expr) bodies)
             ,(annotate-free-vars-expr (cadddr expr) bodies)))
       ((or (relop? tag) (intrinsic? tag))
        `(,tag . ,(annotate-free-vars-expr* (cdr expr) bodies)))
       ((eq? tag 'call)
        `(call ,(cadr expr) . ,(annotate-free-vars-expr* (cddr expr) bodies)))
       ((or (eq? tag 'var) (literal? expr))
        expr)
       ((eq? tag 'lambda)
        ;; (lambda args body) -> (make-closure args (free-vars x*) body-tag)
        (let* ((body-tag (gensym "closure-body"))
               (args (cadr expr))
               (free-vars (find-free-vars (caddr expr) args))
               (body (annotate-free-vars-expr (caddr expr) bodies)))
          (begin (set-car! bodies (cons `(,body-tag ,args ,free-vars ,body) (car bodies)))
                 (let ((closure-var (gensym "closure-var")))
                   `(let ((,closure-var (call %alloc (number ,(closure-tag))
                                              (number ,(max 2 (+ 1 (length free-vars)))))))
                      (begin (%store-mem (var ,closure-var) (number 0) (%function-index ,body-tag))
                             (var ,closure-var)))))))
       (else (begin (display expr) (newline)
                    (error 'annotate-free-vars-expr "unrecognized expr"))))))
  (define (annotate-free-vars-bindings bindings bodies)
    (if (null? bindings)
        '()
        ;; bindings: ((x e) . rest)
        (let ((x (caar bindings))
              (e (annotate-free-vars-expr (cadar bindings) bodies))
              (rest (annotate-free-vars-bindings (cdr bindings) bodies)))
          (cons `(,x ,e) rest))))
  (define (annotate-free-vars-expr* expr* bodies)
    (if (null? expr*)
        '()
        (cons (annotate-free-vars-expr (car expr*) bodies)
              (annotate-free-vars-expr* (cdr expr*) bodies))))

  (define (find-free-vars expr env)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'var) (if (memq (cadr expr) env) '() `(,(cadr expr))))
       ((intrinsic? tag) (find-free-vars-expr* (cdr expr) env))
       (else (begin (trace-value expr)
                    (error 'find-free-vars "unrecognized expr"))))))
  (define (find-free-vars-expr* expr* env)
    (if (null? expr*)
        '()
        (union (find-free-vars (car expr*) env)
               (find-free-vars-expr* (cdr expr*) env))))

  (define (union a b)
    (cond
     ((null? a) b)
     ((memq (car a) b) (union (cdr a) b))
     (else (cons (car a) (union (cdr a) b)))))

  (define (generate-closure-functions bodies)
    (if (null? bodies)
        '()
        (cons (generate-closure-function (car bodies))
              (generate-closure-functions (cdr bodies)))))
  (define (generate-closure-function body)
    ;; (tag args free-vars body) -> (tag . body)
    (let ((closure-var (gensym "closure")))
      (let ((tag (car body))
            ;; Add an extra argument for the closure
            (args (cons closure-var (cadr body)))
            (free-vars (caddr body))
            (body (cadddr body)))
        (if (null? free-vars) ;; for now let's not allow capturing,
                              ;; even though it's not too hard
            `((,tag . ,args) ,body)
            (error 'generate-closure-function "captured variables are not yet supported")))))


  ;; ====================== ;;
  ;; Apply representation   ;;
  ;; ====================== ;;
  (define (apply-representation fn*)
    (if (null? fn*)
        '()
        (cons (apply-representation-fn (car fn*)) (apply-representation (cdr fn*)))))
  (define (apply-representation-fn fn)
    (if (eq? (car fn) '%wasm-import)
        fn
        (let ((def (car fn))
              (body (cadr fn)))
          `(,def ,(apply-representation-expr body)))))
  (define (apply-representation-expr expr)
    (if (and (pair? expr) (symbol? (car expr)))
        (let ((tag (car expr)))
          (cond
           ((eq? tag 'null)
            `(ptr ,(constant-null)))
           ((eq? tag 'bool)
            `(ptr ,(if (cadr expr)
                       (constant-true)
                       (constant-false))))
           ((eq? tag 'char)
            `(ptr ,(tag-constant (char->integer (cadr expr)) (char-tag))))
           ((eq? tag 'begin)
            (cons 'begin (apply-representation-expr* (cdr expr))))
           ((eq? tag 'var) expr)
           ((eq? tag 'number) `(ptr ,(bitwise-arithmetic-shift-left (cadr expr) (tag-size))))
           ((eq? tag 'eof-object) `(ptr ,(constant-eof)))
           ((eq? tag 'call)
            (cons 'call (cons (cadr expr) (apply-representation-expr* (cddr expr)))))
           ((eq? tag 'if)
            (let ((t (cadr expr))
                  (c (caddr expr))
                  (a (cadddr expr)))
              `(if
                ,(apply-representation-pred t)
                ,(apply-representation-expr c)
                ,(apply-representation-expr a))))
           ((eq? tag 'let)
            `(let ,(apply-representation-bindings (cadr expr))
               ,(apply-representation-expr (caddr expr))))
           ((eq? tag '%function-index) expr)
           ((intrinsic? tag)
            (cons tag (apply-representation-expr* (cdr expr))))
           (else (begin (write "unrecognized expr: ")
                        (display expr)
                        (newline)
                        (error 'apply-representation-expr "Unrecognized expr")))))
        (begin (write "error in apply-representation-expr: `")
               (display expr)
               (write "` is malformed")
               (newline)
               (error 'apply-representation-expr "malformed expr"))))
  (define (apply-representation-expr* expr*)
    (if (null? expr*)
        '()
        (cons (apply-representation-expr (car expr*)) (apply-representation-expr* (cdr expr*)))))
  (define (apply-representation-pred pred)
    (let ((tag (car pred)))
      (cond
       ((eq? tag 'zero?) `(zero? ,(apply-representation-expr (cadr pred))))
       ((eq? tag 'eq?) `(eq?
                         ,(apply-representation-expr (cadr pred))
                         ,(apply-representation-expr (caddr pred))))
       ((eq? tag '<) `(<
                       ,(apply-representation-expr (cadr pred))
                       ,(apply-representation-expr (caddr pred))))
       ((eq? tag 'neq?) `(neq?
                          ,(apply-representation-expr (cadr pred))
                          ,(apply-representation-expr (caddr pred))))
       ((eq? tag 'bool) pred)
       (else
        (let ((_ (display pred)))
          (let ((_ (newline)))
            (error 'apply-representation-pred "unrecognized pred")))))))
  (define (apply-representation-bindings bindings)
    (if (null? bindings)
        '()
        (cons `(,(caar bindings)
                ,(apply-representation-expr (cadar bindings)))
              (apply-representation-bindings (cdr bindings)))))

  ;; ====================== ;;
  ;; Compile (make wasm)    ;;
  ;; ====================== ;;
  (define (compile-exprs exprs env)
    (if (null? exprs)
        '()
        (cons (compile-expr (car exprs) env) (compile-exprs (cdr exprs) env))))
  (define (compile-begin exprs env)
    (cond
     ((null? exprs) `((i32.const ,(constant-void))))
     ((and (pair? exprs) (null? (cdr exprs))) `(,(compile-expr (car exprs) env)))
     ((pair? exprs)
      (let ((expr (compile-expr (car exprs) env))
            (rest (compile-begin (cdr exprs) env)))
        (if (eq? (caar exprs) '%store-mem)
            (cons expr rest)
            (cons `(drop ,expr) rest))))
     (else (error 'compile-begin "compile-begin: invalid begin"))))
  (define (compile-expr expr env)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'begin) (cons 'begin (compile-begin (cdr expr) env)))
       ((eq? tag 'number) (cons 'i32.const (cdr expr)))
       ((eq? tag 'ptr) (cons 'i32.const (cdr expr)))
       ((eq? tag 'var) `(get-local ,(cdr (assq (cadr expr) env))))
       ((eq? tag 'call) (cons 'call (cons (cadr expr) (compile-exprs (cddr expr) env))))
       ((eq? tag 'if)
        (let ((t (cadr expr))
              (c (caddr expr))
              (a (cadddr expr)))
          `(if ,(compile-pred t env) ,(compile-expr c env) ,(compile-expr a env))))
       ((eq? tag 'let)
        (let ((index (length env)))
          `(begin
             ,(compile-bindings (cadr expr) env index)
             ,(compile-expr (caddr expr) (bindings->env (cadr expr) env index)))))
       ((eq? tag '%set-car!)
        (let ((p (compile-expr (cadr expr) env))
              (x (compile-expr (caddr expr) env)))
          `(begin (i32.store (offset 0) (i32.and ,p (i32.const ,(fixnum-mask))) ,x)
                  (i32.const ,(constant-void)))))
       ((eq? tag '%set-cdr!)
        (let ((p (compile-expr (cadr expr) env))
              (x (compile-expr (caddr expr) env)))
          `(begin (i32.store (offset ,(word-size)) (i32.and ,p (i32.const ,(fixnum-mask))) ,x)
                  (i32.const ,(constant-void)))))
       ((eq? tag '+)
        (let ((a (compile-expr (cadr expr) env))
              (b (compile-expr (caddr expr) env)))
          `(i32.add ,a ,b)))
       ((eq? tag '-)
        `(i32.sub ,(compile-expr (cadr expr) env) ,(compile-expr (caddr expr) env)))
       ((eq? tag '*)
        (let ((a (compile-expr (cadr expr) env))
              (b (compile-expr (caddr expr) env)))
          ;; Shift only one of them and we don't have to shift back when we're done.
          `(i32.mul (i32.shr_s ,a (i32.const ,(tag-size))) ,b)))
       ((eq? tag '/)
        (let ((a (compile-expr (cadr expr) env))
              (b (compile-expr (caddr expr) env)))
          ;; Shift only one of them and we don't have to shift back when we're done.
          `(i32.shl (i32.div_s (i32.shr_s ,a (i32.const ,(tag-size)))
                               (i32.shr_s ,b (i32.const ,(tag-size))))
                    (i32.const ,(tag-size)))))
       ((eq? tag '%as-fixnum)
        `(i32.and ,(compile-expr (cadr expr) env) (i32.const ,(fixnum-mask))))
       ((eq? tag '%set-tag)
        `(i32.or (i32.and ,(compile-expr (cadr expr) env) (i32.const ,(fixnum-mask)))
                 (i32.shr_s ,(compile-expr (caddr expr) env) (i32.const ,(tag-size)))))
       ((eq? tag '%get-tag)
        `(i32.shl (i32.and ,(compile-expr (cadr expr) env) (i32.const ,(tag-mask)))
                  (i32.const ,(tag-size))))
       ((eq? tag '%read-mem)
        `(i32.load (offset 0) (i32.add ,(compile-expr (cadr expr) env)
                                       (i32.shr_s ,(compile-expr (caddr expr) env)
                                                  (i32.const ,(tag-size))))))
       ((eq? tag '%store-mem)
        ;; (%store-mem base offset value)
        `(i32.store (offset 0)
                    (i32.add (i32.and ,(compile-expr (cadr expr) env) (i32.const ,(fixnum-mask)))
                             (i32.shr_s ,(compile-expr (caddr expr) env)
                                        (i32.const ,(tag-size))))
                    ,(compile-expr (cadddr expr) env)))
       ((eq? tag 'bitwise-and)
        (cons 'i32.and (compile-exprs (cdr expr) env)))
       ((eq? tag 'bitwise-not)
        `(i32.and (i32.not ,(compile-exprs (cdr expr) env))
                  (i32.const ,(fixnum-mask))))
       ((eq? tag 'bitwise-ior)
        (cons 'i32.or (compile-exprs (cdr expr) env)))
       ((eq? tag 'bitwise-arithmetic-shift-left)
        (let ((num (compile-expr (cadr expr) env))
              (shift-amount (compile-expr (caddr expr) env)))
          `(i32.shl ,num (i32.shr_s ,shift-amount (i32.const ,(tag-size))))))
       ((eq? tag 'bitwise-arithmetic-shift-right)
        (let ((num (compile-expr (cadr expr) env))
              (shift-amount (compile-expr (caddr expr) env)))
          `(i32.and (i32.shr_s ,num (i32.shr_s ,shift-amount (i32.const ,(tag-size))))
                    (i32.const ,(fixnum-mask)))))
       ((eq? tag '%unreachable)
        '(unreachable))
       ((eq? tag '%function-index) expr)
       (else (let ((_ (display expr)))
               (let ((_ (newline)))
                 (error 'compile-expr "unrecognized expression")))))))
  (define (compile-pred expr env)
    (let ((op (car expr)))
      (cond
       ((eq? op 'zero?)
        `(i32.eqz ,(compile-expr (cadr expr) env)))
       ((eq? op 'eq?)
        `(i32.eq
          ,(compile-expr (cadr expr) env)
          ,(compile-expr (caddr expr) env)))
       ((eq? op 'neq?)
        `(i32.ne
          ,(compile-expr (cadr expr) env)
          ,(compile-expr (caddr expr) env)))
       ((eq? op '<)
        `(i32.lt_s
          ,(compile-expr (cadr expr) env)
          ,(compile-expr (caddr expr) env)))
       ((eq? op 'bool)
        ;; Since we're in pred context, bools get translated into
        ;; things that go directly into if.
        (if (cadr expr)
            '(i32.const 1)
            '(i32.const 0)))
       (else
        (let ((_ (display expr)))
          (let ((_ (newline)))
            (error 'compile-pred "Unrecognized predicate")))))))

  (define (bindings->env bindings env index)
    (if (null? bindings)
        env
        (cons (cons (caar bindings) index)
              (bindings->env (cdr bindings) env (+ 1 index)))))
  (define (compile-binding binding env index)
    `(set-local ,index ,(compile-expr (cadr binding) env)))
  (define (compile-bindings bindings env index)
    (if (null? (cdr bindings))
        (compile-binding (car bindings) env index)
        `(begin
           ,(compile-binding (car bindings) env index)
           ,(compile-bindings (cdr bindings) env (+ 1 index)))))
  (define (compile-function fn)
    (if (eq? (car fn) '%wasm-import)
        fn
        (let* ((args (number-variables (cdar fn) 0))
               (body (compile-expr (cadr fn) args)))
          `(,(max (count-locals body) (length args)) ;; Number of local variables
            ,body))))

  ;; Determines how many locals were used in a body.
  (define (count-locals body)
    (let ((tag (car body)))
      (cond
       ((eq? tag 'begin)
        (count-locals-exprs (cdr body)))
       ((eq? tag 'call)
        (count-locals-exprs (cddr body)))
       ((eq? tag 'get-local) (+ 1 (cadr body)))
       ((eq? tag 'set-local) (+ 1 (cadr body)))
       ((wasm-simple-op? tag)
        (count-locals-exprs (cdr body)))
       ((eq? tag 'i32.const) 0)
       ((eq? tag '%function-index) 0)
       ((or (eq? tag 'i32.store) (eq? tag 'i32.load))
        (count-locals-exprs (cddr body)))
       ((eq? tag 'if)
        (count-locals-exprs (cdr body)))
       (else (begin (trace-value body)
                    (error 'count-locals "unrecognized expression"))))))
  (define (count-locals-exprs exprs)
    (if (null? exprs)
        0
        (max (count-locals (car exprs)) (count-locals-exprs (cdr exprs)))))

  (define (number-variables vars index)
    (if (pair? vars)
        (cons (cons (car vars) index) (number-variables (cdr vars) (+ 1 index)))
        '()))

  (define (function->type fn)
    ;; Functions are assumed to always return an i32 and take some number of i32s as inputs
    (let ((args (if (eq? (car fn) '%wasm-import)
                    (args->types (cdaddr fn))
                    (args->types (cdar fn)))))
      `(fn ,args (i32))))
  (define (functions->types fns)
    (if (null? fns)
        '()
        (let ((type (function->type (car fns))))
          (cons type (functions->types (cdr fns))))))
  (define (function->name fn)
    (if (eq? (car fn) '%wasm-import)
        (caaddr fn)
        (caar fn)))
  (define (functions->names fns)
    (if (null? fns)
        '()
        (cons (function->name (car fns)) (functions->names (cdr fns)))))

  (define (compile-functions fn*)
    (if (null? fn*)
        '()
        (cons (compile-function (car fn*)) (compile-functions (cdr fn*)))))

  (define (replace-export exports name index)
    (if (null? exports)
        '()
        (let ((ex (car exports))
              (rest (replace-export (cdr exports) name index)))
          (if (or (pair? ex) (not (eq? ex name)))
              (cons ex rest)
              (cons `(fn ,index ,(symbol->string name)) rest)))))

  (define (build-exports exports functions index)
    (if (null? functions)
        exports
        (let ((name (if (eq? (caar functions) '%wasm-import)
                        (caddar functions)
                        (caaar functions))))
          (let ((exports (replace-export exports name index)))
            (build-exports exports (cdr functions) (+ 1 index))))))

  (define (number-list ls i)
    (if (null? ls)
        '()
        (cons i (number-list (cdr ls) (+ 1 i)))))

  (define (wasm-simple-op? op)
    (or (eq? op 'i32.and) (eq? op 'i32.add) (eq? op 'i32.sub) (eq? op 'i32.mul) (eq? op 'i32.div_s)
        (eq? op 'i32.or) (eq? op 'i32.eq) (eq? op 'i32.ne) (eq? op 'i32.not)
        (eq? op 'i32.lt_s) (eq? op 'i32.shr_s) (eq? op 'i32.shl) (eq? op 'drop)
        (eq? op 'unreachable)))

  (define (resolve-calls-exprs exprs env)
    (if (null? exprs)
        '()
        (cons (resolve-calls-expr (car exprs) env) (resolve-calls-exprs (cdr exprs) env))))
  (define (resolve-calls-expr expr env)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'i32.const) expr)
       ((eq? tag 'get-local) expr)
       ((eq? tag 'set-local) `(set-local ,(cadr expr) ,(resolve-calls-expr (caddr expr) env)))
       ((eq? tag 'begin) (cons 'begin (resolve-calls-exprs (cdr expr) env)))
       ((eq? tag 'call) (cons 'call (cons (index-of (cadr expr) env)
                                          (resolve-calls-exprs (cddr expr) env))))
       ((eq? tag '%function-index)
        `(i32.const ,(index-of (cadr expr) env)))
       ((eq? tag 'if)
        (let ((t (cadr expr))
              (c (caddr expr))
              (a (cadddr expr)))
          `(if
            ,(resolve-calls-expr t env)
            ,(resolve-calls-expr c env)
            ,(resolve-calls-expr a env))))
       ((eq? tag 'i32.store)
        (let ((offset (cadr expr))
              (index (resolve-calls-expr (caddr expr) env))
              (value (resolve-calls-expr (cadddr expr) env)))
          `(i32.store ,offset ,index ,value)))
       ((eq? tag 'i32.load)
        (let ((offset (cadr expr))
              (index (resolve-calls-expr (caddr expr) env)))
          `(i32.load ,offset ,index)))
       ((wasm-simple-op? tag)
        (let ((args (resolve-calls-exprs (cdr expr) env)))
          (cons tag args)))
       (else
        (let ((_ (trace-value expr)))
          (error 'resolve-calls-expr "unrecognized expression"))))))
  (define (resolve-calls-fn function env)
    `(,(car function) ,(resolve-calls-expr (cadr function) env)))
  (define (resolve-calls functions env)
    (if (null? functions)
        '()
        (if (eq? (caar functions) '%wasm-import)
            (resolve-calls (cdr functions) env)
            (cons (resolve-calls-fn (car functions) env) (resolve-calls (cdr functions) env)))))
  (define (gather-imports compiled-module)
    (if (null? compiled-module)
        '()
        (let ((rest (gather-imports (cdr compiled-module)))
              (entry (car compiled-module)))
          (if (eq? (caar compiled-module) '%wasm-import)
              (let ((module (cadr entry))
                    (name (symbol->string (caaddr entry)))
                    (type (function->type entry)))
                (cons `(,module ,name ,type) rest))
              rest))))

  ;; ====================== ;;
  ;; Wasm Binary Generation ;;
  ;; ====================== ;;
  (define (number->leb-u8-list n)
    (if (and (< n #x40) (> n (- 0 #x40)))
        `(,(bitwise-and n #x7f))
        (cons (bitwise-ior #x80 (bitwise-and n 127))
              (number->leb-u8-list (bitwise-arithmetic-shift-right n 7)))))
  (define (encode-chars chars)
    (if (null? chars)
        '()
        (cons (char->integer (car chars)) (encode-chars (cdr chars)))))
  (define (encode-string s)
    (let ((chars (string->list s)))
      (make-vec (length chars) (encode-chars chars))))

  (define (wasm-header)
    '(#x00 #x61 #x73 #x6d #x01 #x00 #x00 #x00))

  (define (make-vec length contents)
    (cons (number->leb-u8-list length) contents))

  ;; id is the number, contents is a list of bytes
  (define (byte-count ls)
    (cond
     ((pair? ls) (+ (byte-count (car ls)) (byte-count (cdr ls))))
     ((null? ls) 0)
     (else 1)))
  (define (make-section id contents)
    (cons id (make-vec (byte-count contents) contents)))

  (define (encode-type-vec-contents types)
    (if (null? types)
        '()
        (cons (encode-type (car types)) (encode-type-vec-contents (cdr types)))))

  (define (encode-type-vec types)
    (make-vec (length types) (encode-type-vec-contents types)))

  (define (encode-type type)
    (cond
     ((eq? type 'i32) '(#x7f))
     ((eq? type 'i64) '(#x7e))
     ((eq? type 'f32) '(#x7d))
     ((eq? type 'f64) '(#x7c))
     ;; functions are (fn (t1 ...) (t2 ...)), for t1 ... -> t2 ...
     ((and (pair? type) (eq? (car type) 'fn))
      (cons #x60 (cons (encode-type-vec (cadr type)) (encode-type-vec (caddr type)))))
     (else (let ((_ (trace-value type))) (error 'encode-type "unrecognized type")))))

  (define (wasm-type-section types)
    (make-section 1 (encode-type-vec types)))

  (define (wasm-import-section imports)
    ;; Add 1 to the length because we import a memory too.
    (make-section 2 (make-vec (+ (length imports) 1) (encode-imports imports 0))))
  (define (encode-imports imports index)
    (if (null? imports)
        (encode-memory-import)
        (cons (encode-import (car imports) index) (encode-imports (cdr imports) (+ 1 index)))))
  (define (encode-import import index)
    (let ((module (car import))
          (name (cadr import)))
      (cons (encode-string module)
            (cons (encode-string name)
                  (cons '(#x00) (number->leb-u8-list index))))))
  (define (encode-memory-import)
    (cons (encode-string "memory")
          (cons (encode-string "memory")
                ;; Import a memory with at least 1 page and no maximum.
                '(#x02 #x00 #x01))))

  (define (encode-u32-vec-contents nums)
    (if (null? nums)
        '()
        (cons (number->leb-u8-list (car nums)) (encode-u32-vec-contents (cdr nums)))))
  (define (encode-u32-vec nums)
    (make-vec (length nums) (encode-u32-vec-contents nums)))

  (define (wasm-function-section function-type-ids)
    (make-section 3 (encode-u32-vec function-type-ids)))

  (define (encode-export export)
    (cond
     ((eq? (car export) 'fn)
      (cons (encode-string (caddr export)) (cons #x00 (number->leb-u8-list (cadr export)))))
     (else
      (let ((_ (trace-value export)))
        (error 'encode-export "unrecognized export")))))
  (define (encode-export-contents exports)
    (if (null? exports)
        '()
        (cons (encode-export (car exports)) (encode-export-contents (cdr exports)))))
  (define (wasm-export-section exports)
    (make-section 7 (make-vec (length exports) (encode-export-contents exports))))

  (define (encode-exprs exprs)
    (if (null? exprs)
        '()
        (cons (encode-expr (car exprs)) (encode-exprs (cdr exprs)))))

  (define (encode-simple-op op expr)
    (cons (encode-exprs (cdr expr)) op))

  (define (encode-expr expr)
    (let ((tag (car expr)))
      (cond
       ((eq? tag 'begin)
        (encode-exprs (cdr expr)))
       ((eq? tag 'i32.const)
        (cons #x41 (number->leb-u8-list (cadr expr))))
       ((eq? tag 'i32.eqz)
        (cons (encode-expr (cadr expr)) '(#x45)))
       ((eq? tag 'i32.eq)
        (encode-simple-op #x46 expr))
       ((eq? tag 'i32.ne)
        (encode-simple-op #x47 expr))
       ((eq? tag 'i32.lt_s)
        (encode-simple-op #x48 expr))
       ((eq? tag 'get-local)
        (cons #x20 (number->leb-u8-list (cadr expr))))
       ((eq? tag 'set-local)
        (cons (encode-expr (caddr expr)) (cons #x21 (number->leb-u8-list (cadr expr)))))
       ((eq? tag 'call)
        (cons (encode-exprs (cddr expr))
              (cons #x10 (number->leb-u8-list (cadr expr)))))
       ((eq? tag 'if)
        (let ((t (cadr expr))
              (c (caddr expr))
              (a (cadddr expr)))
          ;; For now, if blocks are assumed to always return i32
          (cons (encode-expr t)
                (cons #x04 (cons #x7f (cons (encode-expr c)
                                            (cons #x05 (cons (encode-expr a) '(#x0b)))))))))
       ((eq? tag 'i32.store)
        (let ((align 0)
              (offset (cadadr expr))
              (index (encode-expr (caddr expr)))
              (value (encode-expr (cadddr expr))))
          (cons (cons index value)
                (cons '(#x36 #x0) ;;always use 0 alignment
                      (number->leb-u8-list offset)))))
       ((eq? tag 'i32.load)
        (let ((align 0)
              (offset (cadadr expr))
              (index (encode-expr (caddr expr))))
          (cons index (cons '(#x28 #x0) ;;always use 0 alignment
                            (number->leb-u8-list offset)))))
       ((eq? tag 'i32.add)
        (encode-simple-op #x6a expr))
       ((eq? tag 'i32.sub)
        (encode-simple-op #x6b expr))
       ((eq? tag 'i32.mul)
        (encode-simple-op #x6c expr))
       ((eq? tag 'i32.div_s)
        (encode-simple-op #x6d expr))
       ((eq? tag 'i32.and)
        (encode-simple-op #x71 expr))
       ((eq? tag 'i32.not)
        (encode-simple-op #x71 expr))
       ((eq? tag 'i32.or)
        (encode-simple-op #x72 expr))
       ((eq? tag 'i32.shl)
        (encode-simple-op #x74 expr))
       ((eq? tag 'i32.shr_s)
        (encode-simple-op #x75 expr))
       ((eq? tag 'drop)
	(encode-simple-op #x1a expr))
       ((eq? tag 'unreachable)
        (encode-simple-op #x00 expr))
       (else
        (let ((_ (trace-value expr)))
          (error 'encode-expr "unrecognized expr"))))))

  (define (encode-code locals body)
    (let ((contents (cons
                     (if (zero? locals)
                         (make-vec 0 '())
                         (make-vec 1 (cons (number->leb-u8-list locals) '(#x7f))))
                     (cons (encode-expr body)
                           '(#x0b)))))
      (make-vec (byte-count contents) contents)))
  (define (encode-codes codes)
    (if (null? codes)
        '()
        (cons (encode-code (caar codes) (cadar codes)) (encode-codes (cdr codes)))))
  (define (wasm-code-section codes)
    (make-section 10 (make-vec (length codes) (encode-codes codes))))

  (define (wasm-name-section names)
    (make-section 0 (cons (encode-string "name")
                          (make-section 1 ;; 1 for function name subsection
                                        (make-vec (length names)
                                                  (encode-name-maps names 0))))))
  (define (encode-name-maps names index)
    (if (null? names)
        '()
        (cons (cons (number->leb-u8-list index) (encode-string (symbol->string (car names))))
              (encode-name-maps (cdr names) (+ 1 index)))))

  ;; Takes a library and returns a list of the corresponding Wasm module
  ;; bytes
  (define (compile-library library)
    ;; (parsed-lib : (exports . functions))
    (let ((parsed-lib (parse-library (expand-macros library))))
      (let ((exports (car parsed-lib)))
        (let* ((closure-converted (convert-closures (cdr parsed-lib)))
               (function-names (functions->names closure-converted))
               (types (functions->types closure-converted))
               (compiled-module (compile-functions
                                 (apply-representation closure-converted))))
          (let ((exports (build-exports exports closure-converted 0))
                (imports (gather-imports compiled-module))
                (functions (resolve-calls compiled-module function-names)))
            (cons (wasm-header)
                  (cons (cons (wasm-type-section types)
                              (cons (wasm-import-section imports)
                                    (cons (wasm-function-section (number-list functions
                                                                              (length imports)))
                                          (cons (wasm-export-section exports)
                                                (wasm-code-section functions)))))
                        (wasm-name-section function-names))))))))
  (define (write-bytes ls)
    (cond
     ((null? ls) #t)
     ((number? ls) (write-char (integer->char ls)))
     (else (let ((_ (write-bytes (car ls))))
             (write-bytes (cdr ls))))))
  (define (compile-stdin->stdout)
    (write-bytes (compile-library (read)))))
